# An Engineering Guide to Implementing an MLIR Dialect

This guide provides the definitive, step-by-step process for adding a new MLIR dialect to the Orchestra project. The instructions herein are based on the successful and robust implementation of the `rock` dialect and reflect the established, correct architectural patterns of this codebase.

Following this guide will ensure that new dialects are implemented correctly, integrate seamlessly with the existing build system, and avoid common pitfalls.

## Core Architectural Concepts

Before starting, it is crucial to understand two key aspects of this project's architecture.

### 1. The Two-Part CMake Build System

This project uses a hybrid CMake configuration that separates TableGen code generation from C++ library compilation.

*   **`include/Orchestra/Dialects/<MyDialect>/CMakeLists.txt`**: This file is responsible *only* for invoking `mlir_tablegen` to generate the declarative `.h.inc` and `.cpp.inc` files from your `.td` source files.
*   **`lib/Orchestra/Dialects/<MyDialect>/CMakeLists.txt`**: This file uses the modern `add_mlir_dialect_library` function to compile your C++ source files (`.cpp`) and link them into a coherent library. It depends on the files generated by the `include`-level CMake file.

This separation is the standard pattern for the project.

### 2. The Modern Approach to Operator Properties

To meet the requirement of using properties for operator attributes (for performance and type safety), this project uses the modern, implicit mechanism provided by MLIR.

*   **You MUST set `let usePropertiesForAttributes = 1;` in your `MyDialect.td` file.**
*   This flag instructs MLIR to automatically use properties as the backing storage for any attributes defined on an operation.
*   You can then define attributes using the standard, simple syntax (e.g., `StrAttr:$my_attribute`).
*   **DO NOT** use explicit `AttrProperty<>` or `let properties = [...]` syntax, as it is incompatible with the TableGen generator used in this project.

---

## Step-by-Step Implementation Guide

This section walks through creating a new dialect named `MyDialect`.

### Step 1: Create the File Structure

First, create the following directory and file structure. You can use the `rock` dialect as a template.

```
orchestra-compiler/
├── include/Orchestra/Dialects/MyDialect/
│   ├── CMakeLists.txt
│   ├── MyDialect.td
│   ├── MyDialectOps.h
│   └── MyDialectOps.td
└── lib/Orchestra/Dialects/MyDialect/
    ├── CMakeLists.txt
    ├── MyDialect.cpp
    └── MyDialectOps.cpp
```

### Step 2: Define the Dialect in TableGen (`.td` files)

1.  **`include/Orchestra/Dialects/MyDialect/MyDialect.td`**

    This file defines the dialect itself. The `usePropertiesForAttributes = 1;` line is mandatory.

    ```tablegen
    #ifndef ORCHESTRA_DIALECT_MYDIALECT_DIALECT_TD
    #define ORCHESTRA_DIALECT_MYDIALECT_DIALECT_TD

    include "mlir/IR/DialectBase.td"

    def MyDialect_Dialect : Dialect {
      let name = "mydialect";
      let cppNamespace = "::mlir::mydialect";

      // This is the crucial flag to enable properties for all attributes.
      let usePropertiesForAttributes = 1;
    }

    #endif // ORCHESTRA_DIALECT_MYDIALECT_DIALECT_TD
    ```

2.  **`include/Orchestra/Dialects/MyDialect/MyDialectOps.td`**

    This file defines the operations of the dialect. Note the simple `StrAttr` syntax for the `arch` attribute, which will be automatically stored as a property.

    ```tablegen
    #ifndef ORCHESTRA_DIALECT_MYDIALECT_OPS_TD
    #define ORCHESTRA_DIALECT_MYDIALECT_OPS_TD

    include "mlir/IR/OpBase.td"
    include "Orchestra/Dialects/MyDialect/MyDialect.td"

    // NOTE: Common types like F32Tensor are available from OpBase.td.
    // Do not add unnecessary includes.

    def MyDialect_ExampleOp : Op<MyDialect_Dialect, "example"> {
      let summary = "An example operation.";
      let arguments = (ins
        StrAttr:$arch,
        F32Tensor:$input
      );
      let results = (outs F32Tensor:$output);
    }

    #endif // ORCHESTRA_DIALECT_MYDIALECT_OPS_TD
    ```

### Step 3: Implement the C++ Bindings

1.  **`include/Orchestra/Dialects/MyDialect/MyDialectOps.h`**

    This header is critical. It must include headers for any MLIR types or interfaces used by the generated code *before* including the `.h.inc` file.

    ```cpp
    #ifndef ORCHESTRA_DIALECTS_MYDIALECT_MYDIALECTOPS_H_
    #define ORCHESTRA_DIALECTS_MYDIALECT_MYDIALECTOPS_H_

    #include "mlir/IR/BuiltinTypes.h"
    #include "mlir/Bytecode/BytecodeOpInterface.h"
    #include "mlir/IR/OpDefinition.h"
    #include "mlir/Interfaces/SideEffectInterfaces.h"

    #define GET_OP_CLASSES
    #include "Orchestra/Dialects/MyDialect/MyDialectOps.h.inc"

    #endif // ORCHESTRA_DIALECTS_MYDIALECT_MYDIALECTOPS_H_
    ```

2.  **`lib/Orchestra/Dialects/MyDialect/MyDialect.cpp`**

    This file provides the implementation for the dialect itself.

    ```cpp
    #include "Orchestra/Dialects/MyDialect/MyDialect.h"
    #include "Orchestra/Dialects/MyDialect/MyDialectOps.h" // Must include Ops.h
    #include "mlir/IR/Builders.h"

    #include "Orchestra/Dialects/MyDialect/MyDialect.cpp.inc"

    void mlir::mydialect::MyDialectDialect::initialize() {
      addOperations<
    #define GET_OP_LIST
    #include "Orchestra/Dialects/MyDialect/MyDialectOps.cpp.inc"
      >();
    }
    ```
    *(You will also need to create `MyDialect.h` and `MyDialectOps.cpp` files, which are mostly boilerplate. Refer to the `rock` dialect for their exact content.)*


### Step 4: Configure the Build System (CMake)

1.  **`include/Orchestra/Dialects/MyDialect/CMakeLists.txt`**

    This file drives TableGen.

    ```cmake
    set(LLVM_TARGET_DEFINITIONS MyDialect.td)
    mlir_tablegen(MyDialect.h.inc -gen-dialect-decls)
    mlir_tablegen(MyDialect.cpp.inc -gen-dialect-defs)

    set(LLVM_TARGET_DEFINITIONS MyDialectOps.td)
    mlir_tablegen(MyDialectOps.h.inc -gen-op-decls)
    mlir_tablegen(MyDialectOps.cpp.inc -gen-op-defs)

    # This custom target is depended on by the C++ library target in lib/.
    add_custom_target(MyDialectIncGen ALL
      DEPENDS
        "${CMAKE_CURRENT_BINARY_DIR}/MyDialect.h.inc"
        "${CMAKE_CURRENT_BINARY_DIR}/MyDialect.cpp.inc"
        "${CMAKE_CURRENT_BINARY_DIR}/MyDialectOps.h.inc"
        "${CMAKE_CURRENT_BINARY_DIR}/MyDialectOps.cpp.inc"
    )
    ```

2.  **`lib/Orchestra/Dialects/MyDialect/CMakeLists.txt`**

    This file builds the C++ library.

    ```cmake
    add_mlir_dialect_library(OrchestraMyDialect
      # List of C++ source files.
      MyDialect.cpp
      MyDialectOps.cpp

      # This dependency ensures .inc files are generated before compilation.
      DEPENDS
      MyDialectIncGen

      # Link against required MLIR libraries.
      LINK_LIBS
      PUBLIC
      MLIRIR
    )
    ```

### Step 5: Integrate the New Dialect

1.  **Edit `orchestra-compiler/lib/Orchestra/CMakeLists.txt`**

    Add your new dialect's subdirectory.

    ```cmake
    # ... existing subdirectories ...
    add_subdirectory(Dialects/MyDialect)
    ```

2.  **Edit `orchestra-compiler/orchestra-opt/CMakeLists.txt`**

    Link the new library to the main `orchestra-opt` tool.

    ```cmake
    target_link_libraries(orchestra-opt
      # ... existing libraries ...
      OrchestraMyDialect
    )
    ```

By following these steps, you will have a well-formed, correctly built, and properly integrated MLIR dialect within the project.