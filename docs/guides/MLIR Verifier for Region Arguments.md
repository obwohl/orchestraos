

# **Architecting Robust Verifiers for Region-Based Operations in MLIR**

## **Foundational Principles of MLIR Operation Verification**

The Multi-Level Intermediate Representation (MLIR) framework provides a powerful and extensible infrastructure for building domain-specific compilers. At its core, this extensibility is realized through the concept of dialects, which allow compiler developers to define custom operations, types, and attributes tailored to a specific domain.1 This freedom, however, necessitates a rigorous mechanism for enforcing the semantic rules and structural invariants of these custom constructs. This mechanism is the operation verifier.

### **The Role of Verifiers in a Dialect-Centric Ecosystem**

In the MLIR ecosystem, a verifier is not merely a debugging aid; it is the ultimate arbiter of correctness for a dialect's invariants. The MLIR pass manager is designed to execute verifiers both before and after every pass, creating a transactional guarantee that the Intermediate Representation (IR) remains in a well-formed state throughout the compilation pipeline.3 This design has profound implications for the entire compiler architecture. By ensuring that passes always operate on valid IR, verifiers simplify the logic within those passes. Transformation authors are freed from the burden of writing defensive code to handle malformed or unexpected IR structures, as they can rely on the invariants guaranteed by the verifiers of the operations they are processing.

This is particularly critical in an extensible system like MLIR, where the set of operations is not fixed. Each dialect defines a contract for its operations, specifying their expected number of operands, results, attributes, and the structural properties of any attached regions.4 The verifier is the primary tool for enforcing this contract. Without robust verification, a dialect's semantics would be ambiguous, leading to a fragile and unpredictable compiler where passes could easily produce incorrect code or crash due to violated assumptions. The verifier, therefore, transforms a collection of custom operations from a mere syntactic representation into a semantically sound and reliable IR.

### **The Phased Verification Pipeline: A Deliberate Design for Correctness**

To manage the complexity of verifying hierarchical IR structures, MLIR employs a multi-stage verification pipeline. This pipeline is not an arbitrary sequence but a carefully designed dependency graph for correctness checks, ensuring that simpler, foundational invariants are established before more complex, region-dependent ones are evaluated. This phased approach is particularly important for operations that contain regions, as it provides a clear separation between verifying the operation itself and verifying the relationship between the operation and the contents of its regions.5

The verification process for an operation can be understood as two distinct phases, especially when regions are involved.

Phase 1: Pre-Region Verification  
This initial phase focuses on the operation's intrinsic properties, without introspecting the contents of its regions. The checks are performed in a specific order to build a foundation of correctness:

1. **Structural Trait Verification:** The process begins with traits that describe fundamental structural properties, such as OneRegion or NoTerminator. These traits often carry their own verifiers that run independently and establish the most basic structural shape of the operation.  
2. **ODS Invariant Verification (verifyInvariants):** Next, the verifier automatically generated by the Operation Definition Specification (ODS) system is executed. This verifier, named verifyInvariants, checks the constraints defined in the operation's TableGen description, such as the number and types of operands, attributes, and results.  
3. **Custom Pre-Region Verification (verify()):** If the operation's TableGen definition includes let hasVerifier \= 1;, a custom C++ method with the signature LogicalResult verify() is called. This is the first opportunity for the dialect author to implement bespoke verification logic. Crucially, this verifier runs *before* the operations inside any attached regions have been verified. It is therefore the appropriate place for checks that depend only on the operation's own arguments and attributes, not on the code within its regions.

Phase 2: Post-Region Verification  
This second phase is executed only for operations that have regions. It is designed for checks that depend on the contents of those regions and can only be performed once the nested operations have themselves been validated.

1. **Region-Aware Trait/Interface Verification:** Traits and interfaces that need to access region contents (marked with verifyWithRegions=1) have their verifiers run at this stage. A prominent example is the IsIsolatedFromAbove trait, whose verifier checks for illegal SSA value captures from the parent scope.8  
2. **Custom Post-Region Verification (verifyRegions()):** If the operation's TableGen definition includes let hasRegionVerifier \= 1;, a custom C++ method with the signature LogicalResult verifyRegions() is invoked. This is the final step in the verification process for the operation.

The deliberate ordering of this pipeline provides a powerful contract. When the verifyRegions() method is called on an operation, the MLIR infrastructure guarantees that all operations nested within its regions have already successfully passed their own full verification pipeline (both Phase 1 and Phase 2, if applicable). This guarantee is fundamental to writing clean and non-redundant verifiers. The author of verifyRegions() does not need to re-verify the internal consistency of nested operations; they can assume those operations are well-formed. The sole responsibility of verifyRegions() is to validate the *relationship* between the parent operation and its immediate children and the structure of its regions—for example, ensuring that a region's terminator yields values whose types are compatible with the parent operation's results.

### **hasVerifier vs. hasRegionVerifier: Choosing the Correct Tool**

The choice between using hasVerifier and hasRegionVerifier in TableGen is a critical architectural decision that directly follows from the phased verification pipeline. Selecting the incorrect hook can lead to verifiers that are either unable to perform necessary checks or that run at an inappropriate time, potentially missing bugs or relying on un-validated IR.

* let hasVerifier \= 1; generates the LogicalResult verify() method. This method is executed during Phase 1, before the contents of the operation's regions are traversed and verified. It is the correct choice for invariants that can be checked by looking only at the operation's operands, attributes, and results. For instance, a verifier checking that an integer attribute falls within a specific range would use this hook.  
* let hasRegionVerifier \= 1; generates the LogicalResult verifyRegions() method. This method is executed at the end of Phase 2, after all nested operations have been fully verified. It is the only correct choice for invariants that depend on the contents of the regions. The user's orchestra.speculate operation, which needs to check the type of its region's terminator (orchestra.yield) and the types of the region's block arguments, falls squarely into this category. Attempting to perform these checks in a verify() method would be incorrect, as the nested orchestra.yield operation would not yet have been verified.

The following table provides a clear guide for selecting the appropriate verifier hook.

| Feature | let hasVerifier \= 1; | let hasRegionVerifier \= 1; |
| :---- | :---- | :---- |
| **Generated C++ Method** | LogicalResult verify() | LogicalResult verifyRegions() |
| **Execution Point** | Before the contents of any attached regions are verified. | After all operations within any attached regions have been fully verified. |
| **Typical Use Case** | Verifying properties of operands, attributes, and results. Enforcing constraints that are independent of region contents. | Verifying properties of operations *inside* the regions (e.g., terminators). Validating the relationship between the parent operation's operands/results and the region's block arguments/terminator operands. Enforcing structural properties of the region itself (e.g., block count). |
| **Recommendation for orchestra.speculate** | Inadequate, as it cannot safely inspect the orchestra.yield terminator or rely on the validity of the region's structure. | **Correct Choice**, as it provides the necessary guarantees and execution context to verify the region's arguments, blocks, and terminators. |

For the orchestra.speculate operation, the requirement to inspect the orchestra.yield terminator and validate the types of the region's block arguments makes hasRegionVerifier the only correct and safe choice.

## **A Deep Dive into Regions, Arguments, and Isolation**

Understanding how to correctly verify an operation like orchestra.speculate requires a firm grasp of three interconnected MLIR concepts: regions, block arguments, and the principle of isolation. The bug in the original verifier—incorrectly forbidding region arguments—stems from a conceptual misunderstanding of how data is permitted to flow into nested scopes in MLIR.

### **Regions as First-Class IR Citizens**

In MLIR's hierarchical structure, an mlir::Operation is the fundamental node of the IR graph. Operations can, in turn, contain mlir::Regions, which are themselves ordered lists of mlir::Blocks.4 It is the

mlir::Block that serves as a container for a sequence of operations and, critically, can define a list of mlir::BlockArguments. These block arguments are SSA values that are scoped to that specific block and are available to all operations within it.11

While it is common to speak of "region arguments," this is a convenient shorthand. Formally, the arguments belong to the entry block of the region. For single-block regions, which are a very common pattern, this distinction is minor. However, for multi-block regions that form a control-flow graph (CFG), each block can have its own distinct set of arguments, which are populated by terminator operations (e.g., cf.br) that branch to it. Recognizing this distinction is key to understanding the precise mechanics of data flow in MLIR.

### **The IsolatedFromAbove Trait: Creating Hermetic Scopes**

The IsolatedFromAbove trait is one of the most important structural properties an operation can have in MLIR.8 When an operation possesses this trait, it makes a powerful assertion: the regions it contains are hermetically sealed from the surrounding SSA scope. No operation inside an isolated region is permitted to directly use an SSA value (

mlir::Value) that is defined outside of that region.

The canonical example of an operation with this trait is func::FuncOp.13 A function in MLIR defines a self-contained unit of code. The only way for data to enter a

func::FuncOp's region is through its function arguments, which are modeled as the block arguments of the function's entry block. The following code is illegal if @my\_func is a standard, isolated function:

MLIR

%c \= arith.constant 42 : i32  
func.func @my\_func() {  
  %v \= "some.op"(%c) : (i32) \-\> i32 // ERROR: %c is defined outside the isolated region  
  return  
}

The verifier for IsolatedFromAbove enforces this rule strictly. This isolation is what enables powerful, modular analyses and transformations, such as parallel pass execution on different functions, because the compiler can reason about each function as a closed world.

The user's original verifier bug likely originated from a misapplication of this isolation principle. It is a common and often correct starting point for new dialect authors to model their operations after fundamental, well-understood operations like func::FuncOp. An implementer observing func::FuncOp would correctly note that its region does not use external SSA values. However, they might incorrectly generalize this specific property of func::FuncOp into a universal rule for all region-bearing operations. This leads to a verifier that forbids block arguments intended for data flow, precisely the error encountered in orchestra.speculate. The orchestra.speculate operation does not represent a self-contained, callable function; it represents a nested scope with controlled data flow, a fundamentally different semantic concept.

### **Non-Isolated Regions: The Mechanism for Structured Dataflow**

The correct model for operations like orchestra.speculate is that of a non-isolated region, which serves as the primary mechanism in MLIR for representing structured control flow. Operations in the Structured Control Flow (scf) dialect, such as scf.if and scf.for, are the quintessential examples of this pattern.16

Consider the scf.for operation, which can have loop-carried variables:

MLIR

%sum\_initial \= arith.constant 0.0 : f32  
%sum\_final \= scf.for %iv \= %c0 to %c10 step %c1 iter\_args(%sum\_iter \= %sum\_initial) \-\> (f32) {  
  %val \= memref.load %A\[%iv\] : memref\<10xf32\>  
  %sum\_next \= arith.addf %sum\_iter, %val : f32  
  scf.yield %sum\_next : f32  
}

In this example, scf.for is not IsolatedFromAbove. Its region has one block argument, %sum\_iter. This block argument acts as a formal parameter for the loop body. The iter\_args clause specifies that the initial value for this argument is provided by the SSA value %sum\_initial, which is an operand to the scf.for operation itself. This creates a clean, explicit channel for data to flow into the region. The verifier for scf.for is responsible for ensuring that the number and types of the iter\_args operands match the number and types of the region's block arguments (after the induction variable).16

This is precisely the pattern required for orchestra.speculate. The operation should be defined without the IsolatedFromAbove trait. Its region's block arguments serve as the formal parameters for the speculative code block. The operation itself will have a corresponding set of SSA operands that provide the actual values to be passed into the region. The verifier's role is not to forbid these arguments but to enforce the type consistency between the operation's operands and the region's block arguments, just as a C++ compiler checks the types of arguments at a function call site against the function's parameter types.

## **A Step-by-Step Implementation of the orchestra.speculate Verifier**

This section provides a complete, production-ready implementation for verifying the orchestra.speculate operation, grounded in the principles of the phased verification pipeline and non-isolated regions. The solution begins with the declarative TableGen definition and culminates in the detailed C++ verifier logic.

### **TableGen Configuration (OrchestraOps.td)**

Correctness in MLIR begins with a precise declarative definition in ODS.6 The TableGen entry for

orchestra.speculate must accurately describe its structure, including its operands, results, and single region. Most importantly, it must signal the need for a custom, region-aware verifier.

The arguments block defines the inputs to the operation. We use Variadic\<AnyType\> for $region\_operands to indicate that the operation can take a variable number of operands of any type, which will be passed to the region. The results block similarly defines the outputs.

The regions block uses SingleBlockRegion to enforce that speculation\_region must contain exactly one block. This is a powerful constraint that simplifies the C++ verifier, as it no longer needs to handle multi-block CFGs.

Finally, and most critically, let hasRegionVerifier \= 1; instructs MLIR's table-driven code generation to create the LogicalResult verifyRegions() method hook, which will contain our custom C++ verification logic.

Code-Snippet

// In OrchestraOps.td

def Orchestra\_SpeculateOp : Orchestra\_Op\<"speculate",\> {  
  let summary \= "Executes a region of code speculatively";

  let description \=;

  let arguments \= (ins Variadic\<AnyType\>:$region\_operands);

  let results \= (outs Variadic\<AnyType\>:$results);

  let regions \= (region SizedRegion:$speculation\_region);

  // Signal to ODS that we are providing a custom C++ verifier that needs to  
  // inspect the contents of the region. This generates the verifyRegions() hook.  
  let hasRegionVerifier \= 1;  
}

def Orchestra\_YieldOp : Orchestra\_Op\<"yield",\> {  
    let summary \= "Yields values from an Orchestra region-based operation";  
    let arguments \= (ins Variadic\<AnyType\>:$operands);  
    // Yield has no results of its own.  
    let results \= (outs);  
}

### **C++ Implementation (OrchestraOps.cpp)**

With the TableGen definition in place, the next step is to implement the verifyRegions() method in C++. This method will systematically check each of the required invariants. The implementation is broken down into logical checks, each with a clear purpose and precise error reporting.

C++

// In OrchestraOps.cpp  
\#**include** "mlir/IR/OpImplementation.h"  
\#**include** "llvm/ADT/TypeSwitch.h"

// Include the auto-generated files  
\#**include** "Orchestra/OrchestraOps.cpp.inc"

using namespace mlir;  
using namespace mlir::orchestra;

//===----------------------------------------------------------------------===//  
// SpeculateOp  
//===----------------------------------------------------------------------===//

LogicalResult SpeculateOp::verifyRegions() {  
  // This is the operation instance we are verifying.  
  auto op \= getOperation();

  // \--- Check 1: Verify that the operation has exactly one region. \---  
  // This is already enforced by \`SizedRegion\` in TableGen, but an explicit  
  // check here provides a clearer error message if the IR is constructed  
  // incorrectly in C++ and bypasses the TableGen builders.  
  if (op-\>getNumRegions()\!= 1) {  
    return emitOpError("must have exactly one region");  
  }

  Region \&region \= getSpeculationRegion();

  // \--- Check 2: Verify that the region has at least one block. \---  
  if (region.empty()) {  
    return emitOpError("region must not be empty");  
  }

  // For this operation, we can also enforce that it has exactly one block.  
  if (\!llvm::hasSingleElement(region)) {  
      return emitOpError("region is expected to have a single block");  
  }

  Block \&entryBlock \= region.front();

  // \--- Check 3: Verify operand-to-argument type mapping. \---  
  // The number of operands passed to the region must match the number of  
  // block arguments in the region's entry block.  
  if (getRegionOperands().size()\!= entryBlock.getNumArguments()) {  
    return emitOpError("has an incorrect number of region operands (")  
           \<\< getRegionOperands().size()  
           \<\< ") that does not match the number of block arguments in the region ("  
           \<\< entryBlock.getNumArguments() \<\< ")";  
  }

  // The types of the operands must match the types of the block arguments  
  // one-to-one.  
  for (auto it : llvm::enumerate(  
           llvm::zip(getRegionOperands().getTypes(), entryBlock.getArgumentTypes()))) {  
    Type operandType \= std::get(it.value());  
    Type argumentType \= std::get(it.value());

    if (operandType\!= argumentType) {  
      return emitOpError("type mismatch between region operand ")  
             \<\< it.index() \<\< " ('" \<\< operandType  
             \<\< "') and corresponding block argument ('" \<\< argumentType  
             \<\< "')";  
    }  
  }

  // \--- Check 4: Verify that all blocks terminate with orchestra.yield. \---  
  // Since we already verified there is only one block, we just check that one.  
  // If the op were to support multiple blocks, this would need to be a loop.  
  Operation \*terminator \= entryBlock.getTerminator();  
  if (\!terminator) {  
    return emitOpError("block in region is not terminated");  
  }

  auto yieldOp \= dyn\_cast\<orchestra::YieldOp\>(terminator);  
  if (\!yieldOp) {  
    return emitOpError("block in region must be terminated by an 'orchestra.yield' op, but found '")  
           \<\< terminator-\>getName() \<\< "'";  
  }

  // \--- Check 5: Verify the yield-to-result type mapping. \---  
  // The number of operands of the orchestra.yield must match the number of  
  // results of the orchestra.speculate operation.  
  if (yieldOp.getOperands().size()\!= op-\>getNumResults()) {  
    return emitOpError("has an incorrect number of results (")  
           \<\< op-\>getNumResults()  
           \<\< ") that does not match the number of operands to the 'orchestra.yield' terminator ("  
           \<\< yieldOp.getOperands().size() \<\< ")";  
  }

  // The types of the yield operands must match the types of the speculate  
  // op's results one-to-one.  
  for (auto it : llvm::enumerate(  
           llvm::zip(yieldOp.getOperands().getTypes(), op-\>getResultTypes()))) {  
    Type yieldOperandType \= std::get(it.value());  
    Type resultType \= std::get(it.value());

    if (yieldOperandType\!= resultType) {  
      return emitOpError("type mismatch between 'orchestra.yield' operand ")  
             \<\< it.index() \<\< " ('" \<\< yieldOperandType  
             \<\< "') and corresponding operation result ('" \<\< resultType  
             \<\< "')";  
    }  
  }

  // If all checks pass, verification succeeds.  
  return success();  
}

### **Emitting Precise and Actionable Diagnostics**

A key feature of a high-quality compiler is its ability to provide clear, actionable feedback when the user provides incorrect input. In the context of MLIR, this means verifiers should emit precise diagnostics when they fail. The emitOpError() method, available on all mlir::Op classes, is the standard tool for this purpose.3

The C++ implementation above demonstrates several best practices for diagnostics:

1. **Specificity:** Each check emits a unique error message that clearly states which invariant was violated (e.g., "type mismatch between region operand...").  
2. **Context:** The messages include contextual information, such as the index of the mismatched operand/argument and the types that were expected versus the types that were found. This allows the user to immediately pinpoint the source of the error in their MLIR source file.  
3. **Clarity:** The error messages are written in clear, human-readable language, avoiding internal compiler jargon where possible. For example, instead of just saying "operand/argument mismatch," the error specifies *which* operand and *which* argument.

This attention to detail in diagnostics is not a minor polish; it is a fundamental part of creating a usable and maintainable compiler infrastructure.

## **Advanced Topics and Common Pitfalls**

Fixing the verifier for orchestra.speculate addresses the immediate problem, but architecting a truly robust dialect requires a broader perspective. This section explores advanced considerations and common pitfalls that developers encounter when working with region-based operations.

### **Handling Multi-Block Regions**

The orchestra.speculate operation was simplified by the SingleBlockRegion constraint in TableGen. However, many operations require regions with complex, multi-block control-flow graphs (CFGs). In such cases, the verification logic for terminators becomes more nuanced.

If a region can contain multiple blocks, the verifier must iterate through all of them and check their terminators. The rules may be more complex than simply "every block must end with a yield." For example, a dialect might define its own conditional branch operation. The verifier would need to ensure that:

* All blocks are terminated.  
* The terminators are one of the allowed types for that region (e.g., orchestra.yield, orchestra.cond\_br).  
* The successors of each terminator are valid blocks within the same region.  
* The operands passed by a branch terminator to a successor block match the types of that block's arguments.  
* The CFG is well-formed (e.g., all blocks are reachable from the entry block).

These checks are essential for maintaining the integrity of SSACFG regions, where the semantics of control flow and data flow are intertwined.21

### **The Triumvirate of Correctness: Verifiers, Builders, and Parsers**

A verifier failure is a symptom, not the root cause. It indicates that invalid IR has been created somewhere in the compiler. While the verifier acts as a crucial safety net, a truly robust system ensures correctness at the point of IR creation. This involves a holistic approach that considers what can be termed the "Triumvirate of Correctness":

1. **The Verifier:** The final arbiter of correctness, as discussed. It validates IR that already exists.  
2. **The Builder:** The C++ OpBuilder API is the primary programmatic interface for creating new operations. When defining custom operations, it is idiomatic to provide custom builder methods that simplify the construction of valid instances. For orchestra.speculate, a custom builder should take the region operands as input, create the operation, and automatically add a region with an entry block that has the correctly typed block arguments. This ensures that any compiler pass or transformation that programmatically creates a SpeculateOp will generate a valid one by default.  
3. **The Parser:** When IR is materialized from its textual form, the parser is responsible for its construction. For operations with custom assembly formats, the dialect author must provide parsing logic. This logic must correctly parse the region operands and the region body, ensuring that the created Block has arguments that match the parsed operands.

By ensuring that the builders and parser always produce structurally sound IR, the verifier's role shifts from constantly catching common errors to being a safeguard against more subtle, unforeseen bugs introduced by complex transformations. This proactive approach to correctness—enforcing invariants at the source—is a hallmark of a mature and reliable compiler.

### **SSA Value Scoping and Dominance in Non-Isolated Regions**

A subtle but critical aspect of non-isolated regions is the rule governing the use of SSA values defined in an outer scope that are *not* explicitly passed as block arguments. The fundamental rule of SSA is that a use of a value must be dominated by its definition. In a hierarchical IR like MLIR, this extends to regions: an operation inside a region can use an SSA value from an outer scope only if the definition of that value dominates the region-bearing parent operation itself.21

For example, in the following code:

MLIR

%c \= arith.constant 1 : i32  
%res \= orchestra.speculate () \-\> (i32) {  
  %v \= arith.addi %c, %c : i32 // This is valid  
  orchestra.yield %v : i32  
}

The use of %c inside the orchestra.speculate region is valid because the definition of %c appears before, and thus dominates, the orchestra.speculate operation.

However, this would be invalid:

MLIR

cf.cond\_br %cond, ^bb1, ^bb2  
^bb1:  
  %c \= arith.constant 1 : i32  
  cf.br ^bb3  
^bb2:  
  %res \= orchestra.speculate () \-\> (i32) {  
    %v \= arith.addi %c, %c : i32 // ERROR: use of %c is not dominated by its definition  
    orchestra.yield %v : i32  
  }  
  cf.br ^bb3  
^bb3:  
  //...

In this case, the definition of %c in ^bb1 does not dominate the orchestra.speculate op in ^bb2. While the orchestra.speculate verifier itself may not need to check for dominance (as this is a general SSA property often checked by the core MLIR verifier), it is essential for the dialect author to understand this rule. This knowledge is critical when writing transformation passes that might move code into or out of the speculative region, as these transformations must preserve SSA dominance properties to maintain IR validity.

## **Conclusion**

The task of implementing a correct verifier for a custom MLIR operation is an exercise in precision and a deep understanding of the framework's architectural principles. The solution to the orchestra.speculate verifier bug is not merely a few lines of C++ code, but a shift in perspective from an incorrect model of region isolation to a correct model of structured data flow.

This report has detailed the modern best practices and idiomatic patterns for this task, leading to several key conclusions for architects of MLIR dialects:

1. **Select the Correct Verifier Hook:** The distinction between hasVerifier (verify()) and hasRegionVerifier (verifyRegions()) is paramount. The choice must be dictated by whether the verification logic requires access to the contents of an operation's regions. For any checks involving terminators, block arguments, or nested operations, verifyRegions() is the only correct and safe option due to the guarantees provided by MLIR's phased verification pipeline.  
2. **The Semantic Contract Dictates Verification:** The verification logic for an operation is a direct reflection of its semantic contract. An operation with the IsolatedFromAbove trait, like func::FuncOp, requires a verifier that forbids external SSA value captures. Conversely, a control-flow operation without this trait, like orchestra.speculate, requires a verifier that *enforces* the consistency of data flow through its region's block arguments.  
3. **A Verifier Validates Relationships:** A well-written verifyRegions() method leverages the guarantee that nested operations are already valid. Its primary role is not to re-validate its children, but to validate the structural and type-based relationships between the parent operation and its immediate contents: its operands to the region's arguments, and the region's terminator operands to its own results.  
4. **Embrace the Triumvirate of Correctness:** True compiler robustness is achieved by ensuring correctness at the point of IR creation. A comprehensive strategy goes beyond the verifier to include disciplined implementation of OpBuilder methods and parsers, which together form a "triumvirate" that proactively constructs valid IR, making verifier failures the exception rather than the rule.

By internalizing these principles, compiler developers can move beyond fixing individual bugs and begin to architect custom dialects that are not only functional but also robust, maintainable, and seamlessly integrated into the broader MLIR ecosystem. The result is a more reliable compiler infrastructure, capable of safely supporting the complex analyses and transformations required for modern, domain-specific language compilation.
