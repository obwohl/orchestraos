

# **Resolving MLIR TableGen Build Failures for Custom Dialect Attributes**

### **Executive Summary: A Definitive Resolution to the mnemonic Resolution Error**

The build failure encountered—Initializer of 'attrName'... could not be fully resolved:\!strconcat("orchestra",\!strconcat(".", mnemonic))—is a direct consequence of the build system configuration. The initial hypothesis is correct: the high-level add\_mlir\_dialect CMake function, while convenient for simple dialects, is not suited for definitions that include custom attributes with their own storage classes. Its use leads to a misinterpretation of the TableGen context, causing the build tool to apply operation-specific logic to attribute definitions.

This report provides a definitive, three-part solution that resolves the immediate error and establishes a robust, scalable foundation for dialect development. The solution involves:

1. **Canonical Attribute Definition:** Correctly defining the custom attribute in a TableGen (.td) file and implementing its corresponding C++ storage class to manage complex data types.  
2. **Logical File Structuring:** Separating the dialect, attribute, and operation definitions into distinct .td files to ensure a clean separation of concerns.  
3. **Granular CMake Implementation:** Employing direct mlir\_tablegen invocations in the CMakeLists.txt file to gain explicit control over the code generation process for each dialect component.

Following this roadmap will not only unblock the current build issue but also align the project with the canonical development practices of the MLIR ecosystem.

## **Part I: Canonical Definition of Complex Custom Attributes in MLIR**

Defining an MLIR attribute with a complex C++ storage type, such as an llvm::ArrayRef of pairs, requires a two-pronged approach: a manually implemented C++ storage class and a corresponding declarative definition in TableGen.

### **1.1 The Anatomy of a Custom C++ Storage Class (ScheduleAttrStorage)**

For attribute parameters that are not simple value types and require heap allocation (like llvm::ArrayRef), MLIR mandates a custom C++ storage class.1 This class dictates the in-memory representation of the attribute's data and integrates with the MLIR context's uniquing mechanism.

The storage class is not merely a data container; it represents a strict contract with the MLIRContext's uniquing system. This contract is fulfilled by implementing a specific set of methods. For pointer-like types such as llvm::ArrayRef, this contract requires that the construct method perform a deep copy of the underlying data into the context's allocator. This is critical for managing memory lifetime correctly, as the ArrayRef passed during construction may point to temporary data that will be destroyed, leading to use-after-free errors if not copied.3

A complete implementation for ScheduleAttrStorage should be placed in a dedicated header file (e.g., OrchestraAttributes.h) and must include the following components:

* **Inheritance:** The class must publicly inherit from mlir::AttributeStorage.2  
* **KeyTy Alias:** A type alias, KeyTy, defines the unique key used by the MLIRContext to identify and unique instances of the attribute. For the ScheduleAttr, this is an llvm::ArrayRef of the pair structure.1  
* **construct Method:** A static factory method, construct, that allocates memory for the storage object using the provided mlir::AttributeStorageAllocator and performs a deep copy of the key data into it.1  
* **operator==:** A comparison method to check for equality between the stored data and a given KeyTy, essential for the uniquing process.1  
* **hashKey Method:** A static hashing function, hashKey, is required for efficient lookup in the context's storage table, unless an llvm::DenseMapInfo specialization already exists for the KeyTy.1  
* **Data Members:** Private members that hold the actual data.

Below is a complete, commented implementation for the storage class:

C++

// In include/Orchestra/OrchestraAttributes.h

\#**ifndef** ORCHESTRA\_ATTRIBUTES\_H  
\#**define** ORCHESTRA\_ATTRIBUTES\_H

\#**include** "mlir/IR/AttributeSupport.h"  
\#**include** "llvm/ADT/ArrayRef.h"  
\#**include** "llvm/ADT/StringRef.h"

// Forward declaration of the attribute class that will be generated by TableGen.  
namespace mlir {  
namespace orchestra {  
class ScheduleAttr;  
} // namespace orchestra  
} // namespace mlir

// Define the storage class in a detail namespace.  
namespace mlir {  
namespace orchestra {  
namespace detail {

struct ScheduleAttrStorage : public mlir::AttributeStorage {  
  using EventTimePair \= std::pair\<llvm::StringRef, int64\_t\>;  
  using KeyTy \= llvm::ArrayRef\<EventTimePair\>;

  // The constructor is simple, just storing the copied data.  
  ScheduleAttrStorage(llvm::ArrayRef\<EventTimePair\> schedule)  
      : schedule(schedule) {}

  // 1\. Comparison method for uniquing.  
  bool operator\==(const KeyTy \&key) const { return key \== schedule; }

  // 2\. Static hashKey method for uniquing.  
  static llvm::hash\_code hashKey(const KeyTy \&key) {  
    return llvm::hash\_value(key);  
  }

  // 3\. Static construct method to allocate and initialize storage.  
  static ScheduleAttrStorage \*construct(  
      mlir::AttributeStorageAllocator \&allocator, const KeyTy \&key) {  
    // Perform a deep copy of the key data into the allocator's memory.  
    llvm::ArrayRef\<EventTimePair\> copiedKey \= allocator.copyInto(key);  
    return new (allocator.allocate\<ScheduleAttrStorage\>())  
        ScheduleAttrStorage(copiedKey);  
  }

  // The actual data stored by the attribute.  
  llvm::ArrayRef\<EventTimePair\> schedule;  
};

} // namespace detail  
} // namespace orchestra  
} // namespace mlir

\#**define** GET\_ATTRDEF\_CLASSES  
\#**include** "Orchestra/OrchestraAttributes.h.inc"

\#**endif** // ORCHESTRA\_ATTRIBUTES\_H

### **1.2 TableGen AttrDef for ScheduleAttr: A Complete Implementation**

With the C++ storage class defined, the next step is to declare the attribute in a TableGen (.td) file. This definition links the declarative attribute to its C++ implementation. It is best practice to place attribute definitions in a separate file, such as OrchestraAttributes.td.2

Code-Snippet

// In include/Orchestra/OrchestraAttributes.td

include "mlir/IR/AttrTypeBase.td"  
include "Orchestra/OrchestraDialect.td"

// A base class for Orchestra attributes to reduce boilerplate.  
class Orchestra\_Attr\<string name, string description \= ""\> :  
    AttrDef\<Orchestra\_Dialect, name\> {  
  let summary \= description;  
  let description \= description;  
}

// Definition for the Schedule Attribute.  
def Orchestra\_ScheduleAttr : Orchestra\_Attr\<"Schedule"\> {  
  let summary \= "An attribute to hold a schedule of (event, time) pairs.";  
  let mnemonic \= "schedule";

  // Link to the manually defined C++ storage class.  
  let storageClass \= "ScheduleAttrStorage";  
  let storageNamespace \= "::mlir::orchestra::detail";

  // Define the parameters that will be passed to the storage class.  
  let parameters \= (ins  
    ArrayRefParameter\<  
      "::std::pair\<::llvm::StringRef, int64\_t\>",  
      "the schedule data"  
    \>:$schedule  
  );

  // Indicate that custom C++ parser/printer methods will be provided.  
  let hasCustomAssemblyFormat \= 1;  
}

### **1.3 Dissecting the AttrDef**

Each field in the AttrDef record provides critical information to mlir-tblgen for generating the attribute's C++ class:

* **storageClass:** A string that must exactly match the name of the C++ storage class (ScheduleAttrStorage).6 This instructs TableGen to use the provided class instead of generating a new one.  
* **storageNamespace:** A string specifying the full C++ namespace of the storageClass (::mlir::orchestra::detail).7 This is essential for the generated code to locate the class definition via a correct  
  \#include.  
* **parameters:** This field declaratively defines the attribute's parameters. Its value must be a dag type.8 The parameter type itself,  
  ArrayRefParameter, is a special TableGen class that provides more information than a raw C++ type string, particularly regarding memory allocation requirements.1  
* **hasCustomAssemblyFormat:** A bit field that, when set to 1, informs TableGen that custom C++ parse and print methods will be manually implemented. This is necessary for any attribute with a non-trivial data structure that cannot be parsed or printed automatically.2

### **1.4 Syntax Deep Dive: (ins...) vs. \[...\] in Parameter Definitions**

The distinction between (ins...) and \[...\] is not stylistic but is a strict type requirement of the TableGen language itself.

* The parameters field within an AttrDef (as well as an OpDef) requires a value of type dag.8  
* In TableGen, a dag literal is defined using the syntax (operator arg0, arg1,...).10 The term  
  ins is a widely used convention for the operator in this context, signifying "inputs" or parameters, but any valid identifier would work.  
* In contrast, the \[...\] syntax defines a list literal in TableGen.12  
* Attempting to assign a list to the parameters field would result in a type mismatch error from mlir-tblgen. Other fields, such as dependentDialects in a Dialect definition, correctly expect a list and must use the \[...\] syntax.13

## **Part II: A Robust CMake Strategy for Multi-File Dialects**

The root cause of the build error is the use of add\_mlir\_dialect, a convenience function that is insufficient for dialects with custom, non-operation components like attributes. A more granular and explicit approach using mlir\_tablegen is required.

### **2.1 Rationale: Why add\_mlir\_dialect Fails for Complex Dialects**

The add\_mlir\_dialect function is a high-level abstraction designed for the common case: a dialect defined primarily by its operations in a single \*Ops.td file.14 It simplifies the build process by implicitly invoking

mlir-tblgen with generators tailored for operations, such as \-gen-op-decls and \-gen-op-defs.

This implicit behavior creates a "context contamination" problem when a .td file contains both OpDef and AttrDef records. The function invokes a single mlir-tblgen instance configured for operation generation. This generator then incorrectly applies OpDef-specific resolution logic to all def records it encounters, including AttrDef records. It attempts to resolve the attrName field of the attribute using logic intended for an opName, which depends on an operation-specific mnemonic field.6 Since the

AttrDef does not have this field, the resolution fails, leading to the observed error. The solution is to enforce context separation by using distinct .td files and dedicated mlir\_tablegen calls for each definition type.

### **2.2 The Granular mlir\_tablegen Approach: A Complete CMakeLists.txt Example**

The canonical solution is to structure the dialect across multiple files and use explicit mlir\_tablegen calls.

**Recommended File Structure:**

* include/Orchestra/OrchestraDialect.td: Defines the Orchestra\_Dialect.  
* include/Orchestra/OrchestraAttributes.td: Defines all custom attributes for the dialect.  
* include/Orchestra/OrchestraOps.td: Defines all operations for the dialect.

CMakeLists.txt Implementation:  
The following CMakeLists.txt (placed in the include/Orchestra/ directory) correctly configures the build for this structure. It uses one mlir\_tablegen invocation per generated file, each with the specific generator flag appropriate for its content.17

CMake

\# In include/Orchestra/CMakeLists.txt

\# Generate Dialect declarations from OrchestraDialect.td.  
mlir\_tablegen(OrchestraDialect.h.inc \-gen-dialect-decls \-dialect=Orchestra  
  \-td-file\=${CMAKE\_CURRENT\_SOURCE\_DIR}/OrchestraDialect.td  
)

\# Generate Attribute declarations and definitions from OrchestraAttributes.td.  
mlir\_tablegen(OrchestraAttributes.h.inc \-gen-attrdef-decls \-attrdefs-dialect=Orchestra  
  \-td-file\=${CMAKE\_CURRENT\_SOURCE\_DIR}/OrchestraAttributes.td  
)  
mlir\_tablegen(OrchestraAttributes.cpp.inc \-gen-attrdef-defs \-attrdefs-dialect=Orchestra  
  \-td-file\=${CMAKE\_CURRENT\_SOURCE\_DIR}/OrchestraAttributes.td  
)

\# Generate Operation declarations and definitions from OrchestraOps.td.  
mlir\_tablegen(OrchestraOps.h.inc \-gen-op-decls  
  \-td-file\=${CMAKE\_CURRENT\_SOURCE\_DIR}/OrchestraOps.td  
)  
mlir\_tablegen(OrchestraOps.cpp.inc \-gen-op-defs  
  \-td-file\=${CMAKE\_CURRENT\_SOURCE\_DIR}/OrchestraOps.td  
)

\# Create a single, public IncGen target that aggregates all generated files.  
\# This simplifies dependency management for the main library.  
add\_public\_tablegen\_target(OrchestraIncGen)

### **2.3 Deconstructing the Build Process: The Role of Each mlir-tblgen Invocation**

Each mlir-tblgen generator flag serves a distinct purpose, producing a specific C++ include file (.inc) that is later incorporated into the dialect's C++ source code. The following table details the most common generators used in dialect development.

| Generator Flag | Output File Suffix | Purpose | C++ \#include Location |
| :---- | :---- | :---- | :---- |
| \-gen-dialect-decls | Dialect.h.inc | Generates the C++ Dialect class declaration. | In the main Dialect header (e.g., OrchestraDialect.h). |
| \-gen-op-decls | Ops.h.inc | Generates C++ class declarations for all operations. | In the main Dialect header (e.g., OrchestraDialect.h). |
| \-gen-op-defs | Ops.cpp.inc | Generates C++ method definitions for all operations. | In the main Dialect source file (e.g., OrchestraDialect.cpp). |
| \-gen-attrdef-decls | Attributes.h.inc | Generates C++ class declarations for TableGen-defined attributes. | In a dedicated attribute header (e.g., OrchestraAttributes.h). |
| \-gen-attrdef-defs | Attributes.cpp.inc | Generates C++ method definitions for TableGen-defined attributes. | In a dedicated attribute source file (e.g., OrchestraAttributes.cpp). |
| \-gen-rewriters | \*Combine.inc | Generates C++ RewritePattern classes from DRR patterns. | In the source file for canonicalization/folding patterns. |

### **2.4 Managing Dependencies: Correctly Linking Generated Code**

The add\_mlir\_dialect\_library function in the parent CMakeLists.txt file must be configured to depend on the generated code.

* **The IncGen Target:** The add\_public\_tablegen\_target(OrchestraIncGen) command creates a single, unified CMake target that represents the successful completion of all preceding mlir\_tablegen commands in that directory.14 This target acts as a crucial synchronization point in the build graph.  
* **The DEPENDS Keyword:** By making the main dialect library DEPENDS on this single IncGen target, a clear and correct build order is established: all code generation must complete before any C++ compilation of the dialect library begins. This prevents file-not-found errors during compilation and ensures a reliable build.14

An example add\_mlir\_dialect\_library invocation would look like this:

CMake

\# In lib/Dialect/Orchestra/CMakeLists.txt

add\_mlir\_dialect\_library(MLIROrchestra  
  OrchestraDialect.cpp  
  OrchestraOps.cpp  
  OrchestraAttributes.cpp

  \# Crucially, depend on the IncGen target from the include directory.  
  DEPENDS  
  OrchestraIncGen

  LINK\_LIBS PUBLIC  
  MLIRIR  
  MLIRSupport  
)

## **Part III: Investigating the Root Cause of the TableGen Error**

A detailed analysis of the error message, combined with an understanding of MLIR's build system and community practices, confirms that the issue is a build configuration error, not a bug in MLIR or TableGen.

### **3.1 Error Analysis: Misinterpretation of AttrDef as Op**

The error message provides the definitive clue:  
Initializer of 'attrName' in 'Orchestra\_ScheduleAttr' could not be fully resolved:\!strconcat("orchestra",\!strconcat(".", mnemonic))  
The expression \!strconcat("orchestra",\!strconcat(".", mnemonic)) is the default TableGen initializer for the opName field within the base Op class definition (OpBase.td). It constructs the full operation name (e.g., orchestra.my\_op) from the dialect name and the operation's mnemonic. The attrName field in the AttrDef class has a different initializer that does *not* involve a mnemonic.

The causal chain is therefore clear:

1. The user places OpDef and AttrDef records in a single .td file.  
2. The add\_mlir\_dialect CMake function is used, which is configured for OpDef processing.  
3. This function invokes mlir-tblgen with an op-centric generator (e.g., \-gen-op-defs).  
4. The generator processes the Orchestra\_ScheduleAttr def but applies the contextual logic of an OpDef.  
5. It attempts to resolve the attribute's name (attrName) using the Op class's name-resolution logic, which requires a mnemonic.  
6. The AttrDef for ScheduleAttr lacks a mnemonic field that can satisfy this expression, causing the TableGen evaluation to fail.

This confirms with certainty that the root cause is a build configuration error leading to a context mismatch inside mlir-tblgen.

### **3.2 Community Precedent and Known Issues Analysis**

A search for this specific error string does not yield a formal bug report.20 This is expected, as this class of error stems from a misconfiguration of the build system rather than a defect in the compiler tooling itself. Such issues are typically resolved through community support and adherence to documented best practices.

The architectural precedent set by the MLIR project itself, as well as established downstream projects like CIRCT, overwhelmingly supports the multi-file, granular build pattern.16 The official MLIR documentation and tutorials for defining dialects with custom attributes and types explicitly demonstrate the pattern of separating definitions and using distinct

mlir\_tablegen calls with the appropriate flags.2 The absence of a specific bug report, combined with the ubiquitous use of this pattern in official documentation and mature projects, constitutes strong evidence that this is the canonical and intended solution. The problem arises from following a known "anti-pattern," for which the documented "pattern" is the fix.

Furthermore, there are no known issues, bugs, or subtle interactions specific to MLIR version 20 that would cause this behavior.23 The mechanisms for defining attributes and configuring CMake have been stable in this regard for many releases.

### **3.3 Synthesis and Final Recommendations**

The initial hypothesis is correct. The blocking build error is a direct result of using the add\_mlir\_dialect convenience function in a scenario it was not designed for. The definitive solution is to abandon this function in favor of an explicit, granular build configuration using direct mlir\_tablegen calls.

To ensure a robust and maintainable dialect, the following best practices should be adopted:

1. **Separate Concerns:** Always separate Dialect, Attribute, Type, and Operation definitions into their own .td files. This prevents context contamination within mlir-tblgen and improves the overall organization and maintainability of the project.  
2. **Explicit is Better than Implicit:** Use direct mlir\_tablegen calls for each generated file. This makes the build process transparent, predictable, and significantly easier to debug.  
3. **Implement Custom Storage for Complex Types:** For any attribute parameter that requires memory allocation (e.g., llvm::ArrayRef, llvm::StringRef), a custom C++ storage class is required. This class must be linked to the TableGen AttrDef via the storageClass and storageNamespace fields.  
4. **Leverage IncGen Targets:** Use a single add\_public\_tablegen\_target to aggregate all generated header targets. This simplifies the DEPENDS clause of the main dialect library definition, making the CMake configuration cleaner and more robust.

By implementing the complete solution and adhering to the best practices outlined in this report, the persistent build error will be resolved, and the Orchestra dialect will be structured on a foundation that is scalable, maintainable, and aligned with the canonical design patterns of the MLIR framework.
