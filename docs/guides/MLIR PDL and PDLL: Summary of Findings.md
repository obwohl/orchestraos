MLIR PDL and PDLL: Summary of Findings

1.1 PDL vs. PDLL: The Dialect and Its Language

MLIR’s pattern rewriting framework uses two related concepts: PDL and PDLL. PDL (Pattern Descriptor Language) is a built-in MLIR dialect that represents rewrite patterns as IR (e.g., pdl.pattern, pdl.operation, etc.). PDLL (humorously Pattern Descriptor Language Language) is a higher‑level, human‑friendly frontend that compiles into the PDL dialect.  In other words, PDLL is a custom textual DSL for patterns, and mlir-pdll translates .pdll files into PDL IR. This two‑layer design lets users write concise, MLIR‑like pattern descriptions (in PDLL) while leveraging MLIR’s own PDL matching engine under the hood ￼ ￼.

1.2 Why PDLL? Overcoming C++ and TableGen Limits

PDLL was motivated by the limitations of both imperative C++ patterns and the older TableGen DRR (Declarative Rewrite Rules). PDLL natively supports MLIR features that TableGen’s DAG grammar cannot easily express. For example, PDLL can directly handle multi‑result ops, ops with nested regions, variadic operands, and other complex constructs ￼ ￼.  In contrast, TableGen would require awkward workarounds (like naming conventions __0, __1 for results) and manual index manipulations.  Moreover, PDLL’s syntax closely follows MLIR assembly, making patterns more readable and maintainable than verbose C++ or terse TableGen definitions ￼ ￼.

PDLL also brings performance and tooling benefits. Pattern bytecode generated by the PDL interpreter is roughly 10× smaller than the equivalent compiled C++ code ￼, greatly reducing binary size.  Pattern merging and IR generation in the PDL interpreter are reported about 15× faster than compiling the same patterns to C++ ￼.  At runtime, the interpreter can “jointly” handle multiple patterns (merging common checks) and has been observed to match patterns faster than hand‑written C++ patterns for the same rules ￼.  Finally, because PDLL patterns are interpreted, new patterns can be loaded at runtime (e.g. from files) without recompiling the compiler, which aids rapid experimentation.

1.3 Key PDLL Concepts

PDLL patterns are declared with the Pattern keyword, with a match clause describing the input IR and a rewrite clause for the transformation.  Constraints or custom checks can be written inline (or delegated to C++ via Constraint/Rewrite blocks).  For complex logic, PDLL allows “escape hatches” to register native C++ functions.  For example, one can declare in PDLL a constraint like Constraint IsPrime(attr: Attr), and then bind it in C++ using patterns.getPDLPatterns().registerConstraintFunction("IsPrime", myIsPrimeFunc).  Upon building a .pdll file, mlir-pdll -x=cpp generates a C++ header (e.g. Patterns.h.inc) that defines a function populateWithGenerated(context, patterns) which adds the PDLL rules to a RewritePatternSet.

The MLIR build integration typically uses CMake custom commands. One invokes mlir-pdll -x=cpp in an add_custom_command to produce a header, wraps it in an add_custom_target, and then adds a dependency from the C++ library or executable.  For example, the MLIR tutorial shows a similar approach for TableGen:

set(LLVM_TARGET_DEFINITIONS FooTransforms.td)
mlir_tablegen(FooTransforms.h.inc -gen-rewriters)
add_public_tablegen_target(MLIRFooTransformIncGen)

We use the analogous process with mlir-pdll, generating a header and hooking it into our target (see Part 2 for details) ￼.  After integration, one typically calls patterns.getPDLPatterns().registerConstraintFunction(...) in C++ to wire up any externals, then uses applyPatternsAndFoldGreedily or similar to apply the interpreted patterns at runtime.

Part 2: Deep Research Inquiries

Research Question 1: Fixing the PassDecls Catch‑22

Issue: When defining MLIR passes via TableGen (-gen-pass-decls), one normally begins the .td file with the base pass include:

include "mlir/Pass/PassBase.td"
def MyPass : Pass<"my-pass"> { ... };

However, using a C‑style #include fails: the mlir-tblgen parser flags Unexpected token at top level #include. Removing the include makes Pass undefined.  This seems like a paradox.

Solution: The error occurs because MLIR’s TableGen expects its own include directive, not the C preprocessor syntax. In MLIR TableGen files you should write:

include "mlir/Pass/PassBase.td"

(Notice no #.) When written correctly, this is recognized by mlir-tblgen. For example, MLIR’s own docs and examples show:

include "mlir/Pass/PassBase.td"
def AffineUnrollPass : Pass<"affine-unroll"> {
  let summary = "Unroll affine loops";
  let description = [{ "Expand affine loop nests completely." }];
};

￼.  Using include (without #) pulls in the Pass definition.

A canonical CMake setup then invokes mlir-tblgen.  For instance:

set(LLVM_TARGET_DEFINITIONS ${CMAKE_CURRENT_SOURCE_DIR}/Passes.td)
mlir_tablegen(Passes.h.inc -gen-pass-decls -name=Orchestra)
add_public_tablegen_target(MLIROrchestraPassIncGen)

This tells CMake to run mlir-tblgen on Passes.td with -gen-pass-decls (and a pass group -name=Orchestra), producing Passes.h.inc. The add_public_tablegen_target creates a dependency target (e.g. MLIROrchestraPassIncGen) that we then link or depend on in the library containing the pass. This pattern mirrors the MLIR tutorials (which use similar lines for rewriter patterns) ￼.

Diagnosing the Catch‑22: In short, the “Unexpected token” error is not an MLIR bug but a syntax issue: TableGen files must use include "...", not #include. Once the include is fixed, Pass is defined and the generator works.  There is no known regression in MLIR 20.1 specifically; indeed, recent MLIR examples (e.g. Jeremy Kun’s tablegen tutorial) all use the correct include syntax ￼. If problems persist, one should also ensure that the MLIR include paths are correctly passed (CMake’s mlir_tablegen macro handles this) and that the TableGen file has no stray characters. Debugging can involve running mlir-tblgen manually with -v or checking mlir-tblgen -gen-pass-decls help to confirm usage. In practice, the fix is simply to remove the # and use:

include "mlir/Pass/PassBase.td"

so that both the base class is found and TableGen accepts the directive. No special workaround or environment issue is needed beyond that proper syntax.

Research Question 2: CMake Integration for PDLL Patterns

To load PDLL patterns in CMake (without Bazel), one uses mlir-pdll in a custom rule. The steps are:
	•	Custom Command: Use mlir-pdll -x=cpp to convert MyPatterns.pdll into a C++ header. For example:

add_custom_command(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/MyPatterns.h.inc
  COMMAND mlir-pdll -x=cpp
          -I ${MLIR_MAIN_INCLUDE_DIR}
          -o MyPatterns.h.inc
          ${CMAKE_CURRENT_SOURCE_DIR}/MyPatterns.pdll
  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/MyPatterns.pdll
  COMMENT "Generating PDLL patterns header"
)

Here we pass -x=cpp so that mlir-pdll emits C++ code (.h.inc). We also include MLIR’s include dirs (-I ${MLIR_MAIN_INCLUDE_DIR}) so tablegen can find any dialect .td files referenced.

	•	Custom Target: Create a target to depend on the generated header:

add_custom_target(MyPatternsIncGen DEPENDS
  ${CMAKE_CURRENT_BINARY_DIR}/MyPatterns.h.inc)

Then make sure your pass library depends on it:

add_library(MyPassLib MyPass.cpp)
add_dependencies(MyPassLib MyPatternsIncGen)
target_include_directories(MyPassLib PRIVATE ${CMAKE_CURRENT_BINARY_DIR})

This ensures the generated header is available before compiling your pass code. It mirrors the “IncGen” pattern used in MLIR (e.g. MLIRFooTransformIncGen) ￼.

	•	Linking MLIR Libraries: Finally, link against the MLIR components that provide PDL support. At minimum, a pass library using PDL patterns should link MLIRPDLDialect and MLIRPDLInterpDialect (the PDL interpreter dialect) as well as the pattern rewrite libraries.  For example:

target_link_libraries(MyPassLib PUBLIC
  MLIRIR                     # core IR utilities
  MLIRPDLDialect             # PDL pattern dialect
  MLIRPDLInterpDialect       # PDL interpreter
  MLIRRewrite                # pattern matching & rewriting engine
  MLIRPatternMatch           # (if separate) generic pattern utilities
  ${MLIR_DIALECT_LIBS}       # all MLIR dialect libraries
  ${MLIR_PASS_LIBS}          # all pass libraries (for mlir-opt tool)
)

The variables ${MLIR_DIALECT_LIBS} and ${MLIR_PASS_LIBS} come from MLIR’s CMake setup and list all core dialect and pass libraries respectively. In particular, running

get_property(dialect_libs GLOBAL PROPERTY MLIR_DIALECT_LIBS)
target_link_libraries(myLib PUBLIC ${dialect_libs})

will automatically add every dialect library (including MLIRPDLDialect and MLIRPDLInterpDialect) ￼. Similarly, ${MLIR_PASS_LIBS} (if defined) can pull in all pass registration libraries. This approach avoids forgetting a required library. In practice, linking MLIRPDLDialect, MLIRPDLInterpDialect, and the main rewrite/pattern library (MLIRRewrite) is essential; other common MLIR libs like MLIRSideEffectInterfaces or MLIRFunc should be added as needed for your passes. The final mlir-opt‑style executable should link the pass library (MyPassLib) along with all dialect and pass libraries so that the new pass is registered.

Overall, a robust CMake setup follows MLIR’s dialect and pass examples: define TABLEGEN steps for the PDLL file, depend on them in your target, and link against the MLIR libraries listed in ${MLIR_DIALECT_LIBS} and ${MLIR_PASS_LIBS} ￼ ￼. This ensures that the generated PDLL code and its dependencies are correctly built and linked.

Sources: MLIR’s official docs and tutorials describe PDL/PDLL and their CMake use ￼ ￼. Jeremy Kun’s MLIR blog also illustrates PDL/PDLL concepts and includes practical examples ￼ ￼. The performance and size benefits of the interpreter have been measured by MLIR developers ￼ ￼. CMake best practices (e.g. using mlir_tablegen macros and get_property(MLIR_DIALECT_LIBS)) are documented in the MLIR tutorials ￼ ￼. These form the basis for the canonical solutions given above.