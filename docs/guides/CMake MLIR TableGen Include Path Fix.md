

# **Resolving MLIR TableGen Include Path Failures in a Target-Centric CMake Environment**

## **Executive Summary and Immediate Resolution**

This report provides a definitive solution and detailed analysis for the C++ include path failure encountered during the compilation of the Orchestra MLIR dialect. The core issue stems from an incorrect CMake configuration for handling headers generated by TableGen. The resolution involves adopting modern, target-centric CMake practices to ensure both the compiler's include path and the build-step dependency order are correctly specified.

### **Bottom Line Up Front: The Corrected CMake Snippet**

To resolve the build failure immediately, replace the relevant section of the top-level orchestra-compiler/CMakeLists.txt file with the following corrected and robust configuration. This snippet addresses not only the visible include path error but also a latent build-ordering defect that could cause intermittent failures in parallel builds.

CMake

\#... (find\_package, project, etc. commands remain unchanged)...

\# This command is acceptable here as it applies to all targets in the project.  
include\_directories(${PROJECT\_SOURCE\_DIR}/include)

\# REMOVED: The global include\_directories for the build path is the source of the issue.  
\# include\_directories(${PROJECT\_BINARY\_DIR}/include)

\# STEP 1: Define the dialect and trigger TableGen code generation.  
\# This function parses Orchestra.td and generates the required.h.inc and.cpp.inc  
\# files. Crucially, it also creates an internal CMake target, conventionally named  
\# 'OrchestraIncGen', which represents the completion of this generation step.  
add\_mlir\_dialect(Orchestra Orchestra/Orchestra.td)

\# STEP 2: Define the C++ library for the dialect.  
\# This command sets up the compilation of your handwritten C++ source files  
\# into the 'Orchestra' library target.  
add\_mlir\_library(Orchestra  
  lib/Orchestra/OrchestraDialect.cpp  
  \#... other.cpp files for the Orchestra library  
    
  \# CRITICAL DEPENDENCY: This 'DEPENDS' argument creates an explicit link in the  
  \# build graph. It guarantees that the 'OrchestraIncGen' target from Step 1  
  \# will fully complete before compilation of this library begins. This is  
  \# essential to prevent race conditions with parallel build tools like Ninja.  
  DEPENDS  
    OrchestraIncGen  
      
  \# Define the libraries that the Orchestra dialect links against.  
  LINK\_LIBS  
    PUBLIC MLIRIR  
    \#... other MLIR/LLVM component dependencies  
)

\# STEP 3: Configure include paths for the 'Orchestra' library target.  
\# ADDED: This is the primary fix. It uses a modern, target-specific command  
\# to add the necessary include directories directly to the 'Orchestra' library.  
target\_include\_directories(Orchestra  
  \# The PUBLIC keyword ensures these include paths are propagated to any other  
  \# target that links against the Orchestra library. This is vital for making  
  \# the dialect's C++ API (including its generated operations) usable by  
  \# other parts of the compiler.  
  PUBLIC

    \# Path to the TableGen-generated headers located in the build directory.  
    \# This directly resolves the 'Orchestra/OrchestraOps.h.inc: No such file or directory' error.  
    "${PROJECT\_BINARY\_DIR}/include"  
)

### **Summary of Corrections**

The provided solution implements two critical changes that align the build system with modern CMake best practices and the intended usage of the MLIR CMake API.

1. **Include Path Correction:** The directory-scoped include\_directories(${PROJECT\_BINARY\_DIR}/include) command has been replaced with the target-scoped target\_include\_directories(Orchestra PUBLIC "${PROJECT\_BINARY\_DIR}/include"). This change directly associates the path to the generated headers with the specific Orchestra library target that requires them, resolving the immediate compilation failure.  
2. **Build Dependency Correction:** A DEPENDS OrchestraIncGen argument has been added to the add\_mlir\_library call. This establishes an explicit dependency in the build graph, ensuring that the TableGen code generation process is completed *before* the C++ compiler is invoked on source files that include the generated headers. This preemptively fixes a potential race condition that is common in parallel build environments like Ninja.

The fundamental principle guiding this solution is a shift from directory-scoped configuration to a more precise and robust target-centric approach. The MLIR build functions, such as add\_mlir\_library, are abstractions that create named library targets. The most reliable way to configure these targets is to modify their properties directly after they have been created, rather than relying on property inheritance from the surrounding directory scope, which can be fragile.

## **Deconstructing the Failure: CMake Scope, Targets, and Modern Best Practices**

The failure of the include\_directories(${PROJECT\_BINARY\_DIR}/include) command is not an error in the command itself, but a misunderstanding of its scope and interaction with modern, abstracted CMake functions. Understanding the distinction between directory-scoped and target-scoped commands is essential for diagnosing and preventing such issues in complex C++ projects.

### **The Critical Distinction: Directory Scope vs. Target Scope**

In CMake, build properties like include paths, compiler definitions, and link libraries can be managed at different levels of granularity. The root of the problem lies in the difference between modifying a directory's properties versus modifying a specific target's properties.

**Directory Scope (include\_directories)**: The include\_directories command is a legacy feature of CMake that operates at the directory level.1 When this command is invoked, it modifies a property of the current

CMakeLists.txt file's scope. Any target defined *after* this command within the same CMakeLists.txt file will inherit this property at the moment of its creation.2 This behavior can be likened to a "sledgehammer" approach: it applies a setting broadly to everything defined within its reach.2

The primary weakness of this approach becomes apparent when using wrapper functions or macros, such as MLIR's add\_mlir\_library. This function is an abstraction that internally calls other functions (like add\_llvm\_library) to ultimately create the Orchestra library target.3 This layering can create a boundary that prevents or alters the inheritance of directory-scoped properties. The target is created deep within a function call, and its properties might be explicitly managed or overwritten by the logic inside

add\_mlir\_library, causing the directory-level setting to be ignored. The failure you observed is a classic symptom of this exact scenario: the directory property was set, but the target created by the abstracted function did not inherit it as expected.

**Target Scope (target\_include\_directories)**: In contrast, the target\_include\_directories command is a modern CMake feature that operates directly on a specific target object.5 This command takes the target's name as its first argument (e.g.,

Orchestra) and modifies its properties directly. This approach is far more precise and deterministic. It does not rely on inheritance or the order of commands within a file. Once a target has been created by a command like add\_library or, in this case, add\_mlir\_library, its properties can be manipulated from the calling scope.6

This "scalpel" approach is the recommended best practice in modern CMake.1 It bypasses the ambiguities of scope inheritance and function abstractions. By calling

add\_mlir\_library(Orchestra...) first to create the target, and then calling target\_include\_directories(Orchestra...) immediately after, the configuration is applied directly and unambiguously to the intended target object. This method is robust against changes in the internal implementation of add\_mlir\_library, making the build system more maintainable and predictable.

### **A Guide to target\_include\_directories: PRIVATE, PUBLIC, INTERFACE**

The target\_include\_directories command requires a keyword—PRIVATE, PUBLIC, or INTERFACE—to specify the "usage requirements" of the include paths being added.5 This provides fine-grained control over how a target's dependencies are propagated through the build graph.

* **PRIVATE**: The include directories are used *only* for compiling the specified target itself. They are not passed on to other targets that link against it. This is appropriate for internal implementation headers that are not part of the library's public API.  
* **INTERFACE**: The include directories are *not* used for compiling the specified target. Instead, they are passed on to any other target that links against it. This is typically used for header-only libraries or for specifying the include requirements of a dependency transitively.  
* **PUBLIC**: This is a combination of PRIVATE and INTERFACE. The include directories are used for compiling the specified target itself, *and* they are passed on to any other target that links against it.2

In the proposed solution, PUBLIC is the correct choice. The TableGen-generated headers (e.g., OrchestraOps.h.inc) are a fundamental part of the Orchestra dialect's public C++ API. They define the C++ classes for the dialect's operations. If another component of the compiler (e.g., a transformation pass or another dialect) were to link against the Orchestra library, it would need access to these same header files to create or inspect orchestra.task operations. By specifying PUBLIC, the build system ensures that any consumer of the Orchestra library automatically receives the necessary include path to its generated headers, fulfilling the transitive dependency.

### **Table 1: Comparison of CMake Include Directory Commands**

The following table summarizes the critical differences between the legacy and modern approaches to managing include directories, distilling the core concepts into an at-a-glance reference.

| Feature | include\_directories(...) | target\_include\_directories(\<target\>...) |
| :---- | :---- | :---- |
| **Scope** | Directory-level. Affects all subsequent targets in the current CMakeLists.txt.1 | Target-level. Affects only the specified \<target\>.5 |
| **Modern Practice** | Legacy. Discouraged for new code due to its broad and often ambiguous scope.6 | **Preferred.** Aligns with modern, target-centric CMake for precision and clarity.1 |
| **Usage Propagation** | None. Paths are not transitively passed to dependent targets. | Full control via PRIVATE, PUBLIC, and INTERFACE keywords to manage transitive dependencies.2 |
| **Granularity** | Low ("sledgehammer"). Prone to "include path pollution," where targets receive unneeded paths. | High ("scalpel"). Precise control over each target's specific dependencies. |
| **Primary Use Case** | Global project-wide paths (e.g., a top-level include directory) in simple projects. | Defining all include dependencies for libraries and executables in any non-trivial project. |

## **The MLIR CMake API: Demystifying the Black Box**

The MLIR build system provides a set of CMake functions like add\_mlir\_dialect and add\_mlir\_library to simplify the process of defining and building dialects. However, these functions are abstractions that hide a multi-stage process. Understanding this process is key to configuring them correctly, especially concerning build order dependencies.

### **The Two-Stage Process: Generation and Compilation**

Building an MLIR dialect from TableGen sources is fundamentally a two-stage process that must occur in a specific order.

Stage 1: Code Generation (add\_mlir\_dialect)  
The first stage is handled by the add\_mlir\_dialect function. Its primary responsibility is to invoke the mlir-tblgen utility with the appropriate flags to parse the dialect's TableGen source file (.td).7 This process reads the Operation Definition Specification (ODS) and generates several C++ source files, including the crucial  
.h.inc and .cpp.inc files that contain the C++ class definitions for your operations and dialect.8

A critical, non-obvious behavior of add\_mlir\_dialect(Foo...) is that it implicitly creates a special-purpose custom CMake target. By convention, this target is named by appending IncGen to the dialect name—in this case, OrchestraIncGen. This IncGen target represents the code generation *step* itself. The build system considers this target "complete" only after mlir-tblgen has successfully run and produced all its output files. This mechanism is the cornerstone of managing dependencies for generated code.7

Stage 2: C++ Compilation (add\_mlir\_library)  
The second stage is handled by the add\_mlir\_library function. Its job is to compile the handwritten C++ source files (e.g., OrchestraDialect.cpp, OrchestraOps.cpp) into a static or shared library.3 These handwritten C++ files are the  
*consumers* of the code generated in Stage 1\. For example, OrchestraOps.cpp will typically \#include "Orchestra/OrchestraOps.h.inc" to access the generated class definitions. This creates a direct dependency: the C++ compilation cannot possibly succeed until the code generation is finished.

### **The Hidden Dependency: Why DEPENDS is Non-Negotiable**

In a simple, sequential build, Stage 1 might happen to complete before Stage 2 begins. However, modern build systems like Ninja are designed for maximum parallelism. Without explicit instructions, Ninja will attempt to execute as many build steps as possible simultaneously to reduce build times.

This creates a high probability of a race condition. Ninja, seeing two independent tasks (running mlir-tblgen and compiling OrchestraOps.cpp), might start the C++ compilation *before* mlir-tblgen has finished creating the OrchestraOps.h.inc file. This would result in the exact same "No such file or directory" error, even if the include path were perfectly configured. This type of failure can be maddeningly intermittent, appearing in some builds but not others, depending on system load and scheduling.

To prevent this, an explicit dependency must be declared in the build graph. The MLIR CMake API provides the DEPENDS keyword within add\_mlir\_library for precisely this purpose.7 By adding

DEPENDS OrchestraIncGen, a clear edge is added to the build graph. This instruction tells CMake, and by extension Ninja, "Do not begin compiling any source file within the Orchestra library until the OrchestraIncGen target has been successfully built."

This makes the build deterministic and correct. The user's current error is an include path issue, but it is masking this more severe, latent build-ordering defect. An expert-level solution must address both issues to ensure the build system is not just functional but also robust and reliable.

### **Alternative: The ADDITIONAL\_HEADER\_DIRS Argument**

An inspection of MLIR's CMake modules and their usage reveals an alternative mechanism for specifying include paths: the ADDITIONAL\_HEADER\_DIRS argument to add\_mlir\_library.11 This argument provides a way to pass include directories directly into the MLIR library function, which then likely forwards them to the underlying

add\_llvm\_library call.

While this approach would also solve the immediate include path problem, it is not the recommended solution for several reasons:

1. **Standardization and Portability**: target\_include\_directories is a fundamental, standard CMake command. Its behavior is well-documented and understood by any developer familiar with modern CMake. In contrast, ADDITIONAL\_HEADER\_DIRS is a custom argument specific to the LLVM/MLIR CMake API. Its behavior is defined by the implementation of add\_mlir\_library, which could change across versions. Relying on the standard command is a more portable and future-proof strategy.  
2. **Clarity and Separation of Concerns**: Using target\_include\_directories promotes a cleaner build script design. The add\_mlir\_library call is responsible for *defining* the library (its name, sources, and link dependencies). The subsequent target\_include\_directories call is responsible for *configuring* one of its properties (its include paths). This separation makes the CMakeLists.txt file easier to read and maintain.  
3. **Environment Brittleness**: The project environment is based on a non-standard development snapshot of MLIR (20.1.8). In such a potentially unstable environment, it is far safer to rely on the well-defined, core functionalities of the underlying build tool (CMake) rather than on custom, higher-level abstractions whose implementation might be in flux or contain bugs in that specific version. The target\_include\_directories approach is guaranteed to work correctly as long as the version of CMake itself is sound.

For these reasons, target\_include\_directories remains the superior and more robust solution.

## **Synthesis: A Production-Ready Build Configuration**

By combining the principles of target-centric configuration and explicit dependency management, it is possible to construct a production-ready CMake configuration for the Orchestra dialect. This configuration is not merely a fix but a template for robustly building any MLIR dialect within a modern CMake project.

### **The Complete, Annotated CMakeLists.txt**

The following block represents the complete and ideal configuration for defining and building the Orchestra dialect library within the main CMakeLists.txt file. The extensive comments serve as inline documentation, explaining the purpose and importance of each command and reinforcing the concepts discussed throughout this report.

CMake

\# \==============================================================================  
\# Orchestra Dialect Definition  
\# This section configures the generation and compilation of the Orchestra dialect.  
\# It follows a three-step process:  
\#   1\. Generate C++ headers from TableGen sources.  
\#   2\. Compile handwritten C++ sources into a library.  
\#   3\. Configure the library's include paths.  
\# \==============================================================================

\# STEP 1: Define the dialect from its TableGen source.  
\# This command instructs CMake how to run mlir-tblgen to generate the  
\# necessary C++ include files (.h.inc,.cpp.inc) from the ODS format.  
\# It also implicitly creates a custom target named 'OrchestraIncGen' that  
\# represents the successful completion of this generation step. This target is  
\# used in Step 2 to establish a build-order dependency.  
add\_mlir\_dialect(Orchestra Orchestra/Orchestra.td)

\# STEP 2: Define the C++ library for the dialect.  
\# This command compiles the handwritten C++ source files that provide the  
\# implementation logic for the dialect, its operations, and related passes.  
add\_mlir\_library(Orchestra  
  \# List of all C++ source files that constitute the library.  
  lib/Orchestra/OrchestraDialect.cpp  
  lib/Orchestra/OrchestraOps.cpp  
  \# Add other.cpp files as needed.

  \# CRITICAL: This establishes a build-order dependency. It ensures that  
  \# the 'OrchestraIncGen' target from Step 1 completes BEFORE CMake  
  \# attempts to compile the C++ files listed above. This is a non-negotiable  
  \# requirement for preventing race conditions in parallel builds (e.g., with Ninja).  
  DEPENDS  
    OrchestraIncGen

  \# List of other MLIR/LLVM libraries that this dialect depends on.  
  \# Using PUBLIC here ensures that these link dependencies are also propagated  
  \# to consumers of the Orchestra library.  
  LINK\_LIBS  
    PUBLIC MLIRIR  
    \#... other dependencies like MLIRPass, MLIRTransforms, etc.  
)

\# STEP 3: Configure the include paths for the C++ library target.  
\# This is the primary fix for the "No such file or directory" error. It uses  
\# the modern, target-centric approach, which is more robust and explicit  
\# than the legacy include\_directories() command.  
target\_include\_directories(Orchestra  
  \# The PUBLIC keyword is essential. It specifies that these include paths are  
  \# part of the Orchestra library's public interface. Any other target that  
  \# links against 'Orchestra' will automatically inherit these include paths,  
  \# which is necessary for them to use the dialect's C++ API.  
  PUBLIC

    \# Path to the dialect's public, handwritten headers (e.g., OrchestraDialect.h).  
    \# This path was previously handled by a global include\_directories call, but  
    \# associating it directly with the target is a cleaner practice.  
    "${PROJECT\_SOURCE\_DIR}/include"

    \# Path to the TableGen-generated headers in the build directory. This path  
    \# is required for the compiler to find files like 'OrchestraOps.h.inc'.  
    "${PROJECT\_BINARY\_DIR}/include"  
)

### **Final Verification and Next Steps**

To apply this solution, replace the existing add\_mlir\_dialect and add\_mlir\_library calls in orchestra-compiler/CMakeLists.txt with the complete block provided above. After making these changes, delete the CMake cache (CMakeCache.txt and the CMakeFiles directory) in the orchestra-compiler/build directory to ensure a clean reconfiguration. Then, re-run the CMake configuration and build commands. The build should now complete successfully without any "No such file or directory" errors.

The principles detailed in this report—target-centric property management and explicit dependency declaration for generated code—are not limited to MLIR. They are universally applicable to any CMake project that involves code generation steps, such as those using Protobuf, gRPC, or other similar tools. Adopting this approach will significantly improve the robustness, clarity, and long-term maintainability of the Orchestra compiler's build system.

#### **Referenzen**

1. include\_directories — CMake 4.1.0 Documentation, Zugriff am August 26, 2025, [https://cmake.org/cmake/help/latest/command/include\_directories.html](https://cmake.org/cmake/help/latest/command/include_directories.html)  
2. What is the difference between include\_directories and target\_include\_directories in CMake? \- Stack Overflow, Zugriff am August 26, 2025, [https://stackoverflow.com/questions/31969547/what-is-the-difference-between-include-directories-and-target-include-directorie](https://stackoverflow.com/questions/31969547/what-is-the-difference-between-include-directories-and-target-include-directorie)  
3. mlir/cmake/modules/AddMLIR.cmake \- toolchain/llvm-project \- Git at Google \- Android GoogleSource, Zugriff am August 26, 2025, [https://android.googlesource.com/toolchain/llvm-project/+/refs/heads/ndk-release-r22/mlir/cmake/modules/AddMLIR.cmake](https://android.googlesource.com/toolchain/llvm-project/+/refs/heads/ndk-release-r22/mlir/cmake/modules/AddMLIR.cmake)  
4. D72554 \[mlir\] support building with BUILD\_SHARED\_LIBS=ON \- LLVM Phabricator archive, Zugriff am August 26, 2025, [https://reviews.llvm.org/D72554](https://reviews.llvm.org/D72554)  
5. target\_include\_directories — CMake 4.1.0 Documentation, Zugriff am August 26, 2025, [https://cmake.org/cmake/help/latest/command/target\_include\_directories.html](https://cmake.org/cmake/help/latest/command/target_include_directories.html)  
6. How to properly add include directories with CMake \- Stack Overflow, Zugriff am August 26, 2025, [https://stackoverflow.com/questions/13703647/how-to-properly-add-include-directories-with-cmake](https://stackoverflow.com/questions/13703647/how-to-properly-add-include-directories-with-cmake)  
7. Creating a Dialect \- MLIR, Zugriff am August 26, 2025, [https://mlir.llvm.org/docs/Tutorials/CreatingADialect/](https://mlir.llvm.org/docs/Tutorials/CreatingADialect/)  
8. MLIR Dialects in Catalyst \- PennyLane Documentation, Zugriff am August 26, 2025, [https://docs.pennylane.ai/projects/catalyst/en/stable/dev/dialects.html](https://docs.pennylane.ai/projects/catalyst/en/stable/dev/dialects.html)  
9. Operation Definition Specification (ODS) \- MLIR \- LLVM, Zugriff am August 26, 2025, [https://mlir.llvm.org/docs/DefiningDialects/Operations/](https://mlir.llvm.org/docs/DefiningDialects/Operations/)  
10. D79242 \[MLIR\] add dependencies for all tablegen targets on 'mlir-headers', Zugriff am August 26, 2025, [https://reviews.llvm.org/D79242](https://reviews.llvm.org/D79242)  
11. llvm-project/mlir/lib/ExecutionEngine/CMakeLists.txt at main \- GitHub, Zugriff am August 26, 2025, [https://github.com/llvm/llvm-project/blob/main/mlir/lib/ExecutionEngine/CMakeLists.txt](https://github.com/llvm/llvm-project/blob/main/mlir/lib/ExecutionEngine/CMakeLists.txt)