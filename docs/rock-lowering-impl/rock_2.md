Implementation Blueprint: Migrating the Rock Dialect to a Property-Based ArchitectureSection 1: Strategic Recommendation: Adopting a Property-Based Op Architecture1.1 Executive Summary of RecommendationThis document presents a comprehensive blueprint for the architectural refactoring of the MLIR rock dialect. The analysis concludes that migrating the dialect's operation definitions from the current attribute-based system to the modern properties mechanism is not merely a stylistic improvement but a critical architectural upgrade. The adoption of properties is the recommended and superior path forward. This migration directly addresses the API fragility and semantic ambiguity inherent in the current design, which complicates the development and maintenance of upstream compiler passes that target the rock dialect, such as the LinalgToRockPass.1 By embracing this change, the rock dialect will become more robust, maintainable, and ergonomic for compiler developers.1.2 Core Benefits RealizedThe transition to a property-based architecture will yield immediate and substantial benefits across the compiler stack, fundamentally improving the quality and safety of the rock dialect.Compile-Time API Safety: The current approach, which relies on defining operation parameters within an Arguments block in TableGen, results in a C++ API that accesses attributes via string-based, dynamically-typed lookups (e.g., op->getAttr("aTransposed")).2 This pattern is brittle; it is susceptible to runtime errors from typos in attribute names and requires extensive boilerplate code for null checks and type casting. The properties mechanism auto-generates strongly-typed C++ getters and setters (e.g., op.getATransposed() -> bool). This shifts error detection from runtime to compile-time, eliminating an entire class of potential bugs and making the C++ API for interacting with rock operations significantly safer and cleaner.Structured and Self-Documenting IR: The existing RockOps.td file defines operation parameters as a flat list of attributes.2 This fails to capture the semantic relationships between parameters, such as the distinction between transposition flags and hardware tuning knobs. The properties system allows for the creation of a structured, hierarchical definition of an operation's semantic contract. Related parameters can be grouped into nested property structs, transforming the TableGen definition into a self-documenting artifact that clearly communicates the architectural intent of each operation. This clarity is essential for developers writing passes that must correctly construct rock operations with complex, performance-critical configurations.1Declarative and Auto-Generated Verification: Currently, many rock operations require custom C++ verifiers, indicated by let hasVerifier = 1; in their TableGen definitions.2 This imperative approach is error-prone and requires significant manual effort. The properties framework enables the declarative specification of invariants directly within TableGen (e.g., marking a property as required or providing a default value). MLIR can then leverage these declarations to auto-generate more robust and reliable verifiers, ensuring that IR invariants are enforced at the point of construction and parsing, thereby reducing the burden on developers and improving the overall correctness of the dialect.Section 2: The New rock Dialect Contract: Property-Driven Operation DefinitionsThis section deconstructs the existing attribute-based contract of the rock dialect and defines its new, property-based successor. The objective is to establish a clear, unambiguous, and type-safe interface for all rock operations, which will serve as a stable and predictable target for higher-level dialect lowerings.2.1 Foundational Property Structs for ReusabilityAn analysis of the current RockOps.td file reveals recurring sets of parameters across multiple high-level operations. For instance, Rock_ConvOp, Rock_GemmOp, and Rock_AttentionOp all contain optional attributes for derivedBlockSize, gridSize, and params, which collectively represent hardware-specific tuning configurations.2 The current flat structure leads to code duplication and potential inconsistencies.To address this, the new contract will introduce reusable property structs. This approach elevates a recurring concept—such as tuning parameters—into a first-class architectural construct. By defining these parameter groups in a central location, we enforce consistency, reduce boilerplate in individual operation definitions, and create a more organized and intuitive C++ API (e.g., op.getTuningParams().getBlockSize()). This architectural modernization is a direct response to the need for a well-defined "rocMLIR contract" for lowering passes.1A primary candidate for this abstraction is a TuningParams struct, which can be defined in RockAttrDefs.td as follows:Code-Snippet// In mlir/Dialect/Rock/IR/RockAttrDefs.td

def Rock_TuningParams : StructAttr<"TuningParams", Rock_Dialect,> {
  let cppNamespace = "::mlir::rock";
}
2.2 Case Study: Refactoring rock.gemmThe rock.gemm operation is the quintessential compute kernel in the dialect and a primary target for lowering from linalg.1 Its refactoring serves as the definitive blueprint for all other operations. The current definition uses a mix of UnitAttr for boolean flags (e.g., $aTransposed), OptionalAttr for nullable tuning parameters, and specific attribute types like StoreMethodAttr.2 This will be mapped to a clean, strongly-typed property structure.The following table provides the central translation key for this migration. It offers a clear, line-by-line guide for developers, detailing how the old, untyped attribute definitions map to the new, strongly-typed property world and explaining the rationale and C++ API impact of each change.Table 2.1: rock.gemm Attribute-to-Property MappingOld Attribute Definition (Arguments)New Property Definition (properties)Rationale / C++ API ImpactUnitAttr:$aTransposedDefaulted<Bool, "false">:$aTransposedReplaces op->getAttr("aTransposed") with op.getATransposed() -> bool. Makes the default explicit and eliminates null checks.UnitAttr:$bTransposedDefaulted<Bool, "false">:$bTransposedReplaces op->getAttr("bTransposed") with op.getBTransposed() -> bool.UnitAttr:$cTransposedDefaulted<Bool, "false">:$cTransposedReplaces op->getAttr("cTransposed") with op.getCTransposed() -> bool.StoreMethodAttr:$storeMethodProp<StoreMethodAttr>:$storeMethodCreates a typed getter op.getStoreMethod() -> StoreMethod. Being a required property (Prop<>) ensures it is never null.OptionalAttr<Rock_GemmFeaturesAttr>:$featuresOptional<Rock_GemmFeaturesAttr>:$featuresGenerates op.getFeatures() -> std::optional<GemmFeatures>. This is more idiomatic C++ than a nullable attribute pointer.OptionalAttr<I32Attr>:$derivedBlockSizeOptional<I32>:$derivedBlockSizeGenerates op.getDerivedBlockSize() -> std::optional<int32_t>. Directly returns the integer value, removing the need for .getValue().OptionalAttr<I32Attr>:$gridSizeOptional<I32>:$gridSizeGenerates op.getGridSize() -> std::optional<int32_t>.OptionalAttr<RockTuningParamAttrInterface>:$paramsOptional<RockTuningParamAttrInterface>:$paramsGenerates op.getParams() -> std::optional<...Interface>.Based on this mapping, the new TableGen definition for Rock_GemmOp in RockOps.td will be:Code-Snippetdef Rock_GemmOp
    : Rock_Op<"gemm",> {
  let summary = "General matrix multiplication (GEMM)";
  let description = [{...}]; // Description remains the same

  let arguments = (
    ins Arg<TensorOrMemRefOf<GemmInputTypes>, "matrix A",>:$a,
    Arg<TensorOrMemRefOf<GemmInputTypes>, "matrix B",>:$b,
    Arg<TensorOrMemRefOf<GemmOutputTypes>,
        "matrix C",>:$c
  );
  let results = (outs Optional<AnyRankedTensor>:$result);

  let properties = (
    // The 'properties' keyword replaces the 'Arguments' list for attributes.
    Defaulted<Bool, "false">:$aTransposed,
    Defaulted<Bool, "false">:$bTransposed,
    Defaulted<Bool, "false">:$cTransposed,
    Prop<StoreMethodAttr>:$storeMethod,
    Optional<Rock_GemmFeaturesAttr>:$features,
    Optional<I32>:$derivedBlockSize,
    Optional<I32>:$gridSize,
    Optional<RockTuningParamAttrInterface>:$params
  );

  // The assembly format will be updated to use the new property names.
  // The framework provides a reasonable default, but it can be customized.
  let assemblyFormat =;

  // The generic verifier is no longer needed; property constraints are
  // checked automatically. Custom, non-property logic can still be added.
  let hasVerifier = 0;
}
2.3 Extending the Contract to Other OperationsThe same refactoring principles will be applied consistently across the dialect to ensure a uniform and predictable API.Rock_ConvOpBase: The convolution base class and its derivatives (Rock_ConvOp, Rock_ConvBwdDataOp, etc.) will be refactored.2 The IndexArrayLength attributes for padding, strides, and dilations will be migrated to Prop<DenseI64ArrayAttr> properties. This provides a strongly-typed DenseI64ArrayAttr via the C++ getter, which is more robust than the current generic attribute access. The common tuning parameters will leverage the Rock_TuningParams struct if it is defined.Rock_AttentionOp: This complex operation has numerous boolean flags like $qTransposed, $kTransposed, $vTransposed, $oTransposed, and $causal, all defined as UnitAttr.2 These are ideal candidates for migration to Defaulted<Bool, "false"> properties. This change will significantly clean up both the TableGen definition and the C++ class, making the operation easier to construct and inspect programmatically.Section 3: A Phased Implementation GuideThis section provides a concrete, step-by-step guide for executing the migration from an attribute-based to a property-based architecture within the rock dialect's TableGen source files.3.1 Phase 1: Defining Base Property StructsThe first step is to establish any reusable property structures that were identified. This centralizes common definitions and promotes consistency.Navigate to and open the mlir/Dialect/Rock/IR/RockAttrDefs.td file.Add the TableGen definitions for any new StructAttr classes, such as the Rock_TuningParams struct proposed in Section 2.1. This ensures these definitions are available before they are referenced by individual operations.3.2 Phase 2: Migrating Core Compute OperationsWith base definitions in place, the core compute operations can be migrated. The process for each operation is methodical.Navigate to and open the RockOps.td file.2Locate the definition for Rock_GemmOp.Modify the Arguments<(...)> block to remove all attribute definitions (e.g., UnitAttr:$aTransposed, OptionalAttr<I32Attr>:$derivedBlockSize). The Arguments block should now only contain the operation's SSA-value operands (inputs).Add a new let properties = (...) block immediately after the results block.Populate the properties block with the new property definitions as specified in Table 2.1.Change let hasVerifier = 1; to let hasVerifier = 0;. This disables the generic C++ verifier hook and allows the MLIR framework's auto-generated property verification to take over. If the operation requires custom verification logic in addition to property checks, this can be left as 1, but the goal is to rely on the declarative system where possible.Repeat this process for other key operations like Rock_ConvOpBase and Rock_AttentionOp, translating their respective attributes to appropriate properties.3.3 Phase 3: Updating Assembly FormatsThe textual representation of the operations in .mlir files will change, and the assemblyFormat string in TableGen must be updated to reflect this.Within each modified operation definition in RockOps.td, locate the let assemblyFormat = [{...}]; line.The generic attr-dict directive prints all attributes that are not explicitly handled by the format string. Since the migrated parameters are now properties, they will be printed by default in a generic format (e.g., properties = {aTransposed = true,...}).To maintain a clean and readable assembly format similar to the original, a custom printer can be used. The recommended approach is to use a combination of explicit property printing for key flags and a generic printer for the rest. For example, the rock.gemm format can be updated to explicitly print the transposition flags while grouping other properties.3.4 Phase 4: Code Generation and Build VerificationOnce the TableGen files are updated, the corresponding C++ source files must be regenerated.From the build directory, trigger the MLIR TableGen build process (e.g., by running ninja <target> or make). This will invoke mlir-tblgen and overwrite the auto-generated C++ header and source files (e.g., RockOps.h.inc, RockOps.cpp.inc).Attempt a full build of the compiler project. This build is expected to fail with numerous compilation errors. These errors will occur in any C++ file that interacts with the old attribute API of the migrated rock operations. These errors serve as a precise guide for the C++ API transition detailed in the next section.Section 4: Navigating the C++ API Transition and Downstream Pass MigrationThe changes made in TableGen are not self-contained; they fundamentally alter the C++ class definitions for each rock operation, creating a ripple effect across the entire compiler ecosystem. Any existing code that creates, modifies, or inspects these operations will be broken by the API change. This section provides the necessary guidance for migrating the C++ code, with a specific focus on updating compiler passes like LinalgToRockPass.14.1 The New C++ Op InterfaceThe primary impact of the migration is the replacement of the generic, string-based attribute API with a set of strongly-typed, named accessor methods. Developers must replace all instances of the old API calls with their new, type-safe equivalents. This is not merely a syntactic change; it represents a fundamental shift towards safer and more expressive code. For example, accessing an optional integer property now involves std::optional, which is more idiomatic and safer in modern C++ than handling potentially null IntegerAttr pointers.The following table provides concrete, side-by-side code snippets for the most common C++ interactions with an MLIR operation, serving as a practical cookbook for resolving the build errors identified in Phase 4.Table 4.1: C++ API Comparison: Attribute vs. Property AccessTaskOld API (Attribute Dictionary)New API (Properties)Check for a boolean flagif (op->getAttr("aTransposed")) {... }if (op.getATransposed()) {... } (The getter for Defaulted<Bool> always returns a bool)Get an optional integer valueauto sizeAttr = op->getAttrOfType<IntegerAttr>("derivedBlockSize"); if (sizeAttr) { int32_t bs = sizeAttr.getInt();... }if (auto bs = op.getDerivedBlockSize()) { use(*bs); } (Uses std::optional<int32_t>)Get a required enum attributeStoreMethod method = op.storeMethod().getValue(); (Requires a separate null check on op.storeMethod())StoreMethod method = op.getStoreMethod(); (Getter for Prop<> returns the value directly, guaranteed non-null)4.2 Updating Operation Builders and VerifiersThe mechanism for creating new operations is significantly impacted. The rewriter.create<...>() calls must be updated to use the new property-based builder. While the old builder accepted a flat, variadic list of Values and Attributes, the new primary builder accepts the operation's operands and a Properties struct. This approach is more verbose but also more explicit and type-safe, preventing errors where attributes are passed in the wrong order or with the wrong type.Additionally, custom C++ verifiers that previously checked for the presence and type of attributes should be re-evaluated. Much of this logic is now handled automatically by the declarative constraints in the property definitions. Custom verifiers should be simplified to only contain logic that cannot be expressed declaratively in TableGen.4.3 Practical Example: Updating the LinalgToRockPassThis section provides a concrete, real-world example of how to adapt a downstream pass to the new dialect contract, using the LinalgGEMMToRockGEMMPattern from the LinalgToRockPass review as a case study.1 The matchAndRewrite function, which is responsible for creating the new rock.gemm op, must be completely overhauled.Before (Conceptual code based on old attribute list):C++// In LinalgGEMMToRockGEMMPattern::matchAndRewrite
//...
// Fictional builder based on a flat list of attributes.
// This style is fragile and relies on correct ordering and types.
rewriter.create<mlir::rock::Rock_GemmOp>(
    op.getLoc(),
    A, B, C,
    transposeA? rewriter.getUnitAttr() : nullptr,
    transposeB? rewriter.getUnitAttr() : nullptr,
    transposeC? rewriter.getUnitAttr() : nullptr,
    storeMethodAttr,
    featuresAttr, // Can be null
    rewriter.getI32IntegerAttr(blockSize),
    rewriter.getI32IntegerAttr(gridSize),
    paramsAttr // Can be null
);
rewriter.eraseOp(op);
After (Using the new Property-based builder):C++// In LinalgGEMMToRockGEMMPattern::matchAndRewrite
//...
// 1. Instantiate the Properties struct for the target operation.
mlir::rock::Rock_GemmOp::Properties properties;

// 2. Populate the properties in a type-safe manner.
properties.aTransposed = transposeA; // Assigns a bool directly
properties.bTransposed = transposeB;
properties.cTransposed = transposeC;
properties.storeMethod = storeMethod; // Assigns the StoreMethod enum
if (features) properties.features = features; // Assigns an optional attribute
properties.derivedBlockSize = blockSize; // Assigns an optional<int32_t>
properties.gridSize = gridSize;
if (params) properties.params = params;

// 3. Use the new builder, which takes operands and the properties struct.
// The result types must also be provided.
rewriter.create<mlir::rock::Rock_GemmOp>(
    op.getLoc(),
    op->getResultTypes(),
    ValueRange{A, B, C},
    properties
);
rewriter.eraseOp(op);
This "after" example demonstrates the improved developer experience. The property names are checked by the C++ compiler, and the types are enforced, preventing a wide range of potential integration errors when building lowering passes.Section 5: A Robust Testing and Verification StrategyThe architectural migration must be accompanied by a corresponding update to the project's testing infrastructure to ensure correctness and prevent regressions. The strategy involves updating existing tests and adding new ones to validate the enhanced verification capabilities of the property-based system.5.1 Updating the Assembly Format in lit TestsThe changes to the assemblyFormat in the .td files will break all existing lit tests that use FileCheck to verify the textual IR output. These tests must be systematically updated.Action: All .mlir test files that contain rock operations must be reviewed. The CHECK: lines will need to be modified to match the new assembly format. For example, a generic attributes {... } block may be replaced by a more structured properties = #rock.properties<blockSize = 256,...> format. This is a tedious but essential process to ensure the test suite remains valid.5.2 New Test Cases for Property InvariantsThe migration to properties enables more powerful, declarative verification that is automatically enforced by the MLIR framework. The test suite must be expanded to validate that these new verifiers are working correctly.Action: Create a new set of lit test files designed to fail. These tests should attempt to define rock operations with invalid property configurations. For example:A test that omits a required property (one defined with Prop<>).A test that provides a property with the wrong attribute type (e.g., a StringAttr where an IntegerAttr is expected).These test files should use // expected-error comments to assert that the IR parser correctly identifies and reports the errors, confirming that the auto-generated verifiers are functioning as intended.5.3 End-to-End Integration TestingWhile unit tests for IR parsing and verification are critical, they are not sufficient. The full end-to-end compilation and execution test suite must pass to guarantee that the architectural refactoring has not introduced any semantic regressions.Action: After the LinalgToRockPass and all other dependent C++ components have been migrated to the new API, the project's full integration test suite must be executed. This ensures that the generated rock operations, although constructed via a new API, still lower correctly to executable GPU code and produce the correct numerical results. This final step validates that the refactoring was a pure architectural improvement with functionally equivalent output.ConclusionThe migration of the rock dialect to a property-based architecture is a strategic investment in the long-term health and scalability of the compiler. It replaces a fragile, error-prone system with a modern, type-safe, and self-documenting contract. This change will significantly improve the developer experience for anyone working with the rock dialect, particularly those implementing the critical lowering passes that bridge the gap between high-level linear algebra and hardware-specific kernels.By following the phased implementation guide, navigating the C++ API transition with the provided examples, and executing a robust testing strategy, the development team can successfully execute this migration. The result will be a more resilient, maintainable, and correct compiler infrastructure, better equipped to handle the complexities of generating high-performance code for AMD GPUs.