// orchestra-compiler/lib/Orchestra/Transforms/SpeculateIfOp.pdll
//
// This file contains the PDL pattern for speculating scf.if operations.
// It replaces the imperative C++ SpeculateIfOpPattern.
//
// See Task 1.2 in `next/upgrade_plan.md`.

#include "Orchestra/Orchestra.td"
#include "mlir/Dialect/SCF/IR/SCFOps.td"

// Native C++ constraint to check that the operation has results.
Constraint HasResults(op: Op) [{
  return op->getNumResults() > 0 ? mlir::success() : mlir::failure();
}];

// Native C++ constraint to check that the 'else' region is not empty.
Constraint HasElseBlock(op: Op) [{
  auto ifOp = cast<scf::IfOp>(op);
  return ifOp.getElseRegion().hasOneBlock() ? mlir::success() : mlir::failure();
}];

// Native C++ constraint to check for side effects.
Constraint RegionsHaveNoSideEffects(op: Op) [{
  auto ifOp = cast<scf::IfOp>(op);
  auto hasSideEffects = [&](mlir::Region &region) {
    auto walkResult = region.walk([&](mlir::Operation *op) {
      auto memInterface = dyn_cast<mlir::MemoryEffectOpInterface>(op);
      if (!memInterface)
        return mlir::WalkResult::advance();

      llvm::SmallVector<mlir::MemoryEffects::EffectInstance> effects;
      memInterface.getEffects(effects);
      for (const auto &effect : effects) {
        if (isa<mlir::MemoryEffects::Write>(effect.getEffect())) {
          return mlir::WalkResult::interrupt(); // Found a write side effect.
        }
      }
      return mlir::WalkResult::advance();
    });
    return walkResult.wasInterrupted();
  };

  if (hasSideEffects(ifOp.getThenRegion()) ||
      hasSideEffects(ifOp.getElseRegion())) {
    return mlir::failure();
  }
  return mlir::success();
}];

// Define the native C++ rewriter for the speculative execution pattern.
Rewrite RewriteSpeculativeIf(op: Op) -> (ValueRange) [{
  auto ifOp = cast<scf::IfOp>(op);
  mlir::Location loc = ifOp.getLoc();
  mlir::TypeRange resultTypes = ifOp.getResultTypes();

  // Create the target attribute.
  mlir::Builder builder(ifOp.getContext());
  auto archAttr = builder.getStringAttr("unknown");
  auto targetAttr = builder.getDictionaryAttr({builder.getNamedAttr("arch", archAttr)});

  rewriter.setInsertionPoint(op);
  auto thenExternalValues = getUsedExternalValues(ifOp.getThenRegion());
  auto thenTask = rewriter.create<orchestra::TaskOp>(
      loc, resultTypes, targetAttr);
  thenTask.getBody().push_back(new mlir::Block());
  cloneAndRemap(ifOp.getThenRegion(), thenTask.getBody(), thenExternalValues, rewriter);

  rewriter.setInsertionPoint(op);
  auto elseExternalValues = getUsedExternalValues(ifOp.getElseRegion());
  auto elseTask = rewriter.create<orchestra::TaskOp>(
      loc, resultTypes, targetAttr);
  elseTask.getBody().push_back(new mlir::Block());
  cloneAndRemap(ifOp.getElseRegion(), elseTask.getBody(), elseExternalValues, rewriter);

  rewriter.setInsertionPoint(op);
  llvm::SmallVector<mlir::Value> commitValues;
  commitValues.append(thenTask.getOperation()->getResults().begin(), thenTask.getOperation()->getResults().end());
  commitValues.append(elseTask.getOperation()->getResults().begin(), elseTask.getOperation()->getResults().end());
  auto num_true = thenTask.getOperation()->getNumResults();
  auto selectOp = rewriter.create<orchestra::SelectOp>(
      loc, resultTypes, ifOp.getCondition(), commitValues, num_true);

  return selectOp.getResults();
}];


// The main pattern definition.
Pattern SpeculateIfOpPattern with benefit(1) {
  // 1. Match the root operation and apply constraints.
  let ifOp = op<scf.if>;
  HasResults(ifOp);
  HasElseBlock(ifOp);
  RegionsHaveNoSideEffects(ifOp);

  // 2. Call the rewriter to perform the transformation.
  replace ifOp with RewriteSpeculativeIf(ifOp);
}
